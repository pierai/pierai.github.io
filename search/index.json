[{"content":".d.ts\r.d.ts 文件是 TypeScript 中的类型声明文件，专门用于声明类型信息。它们通常用于以下情况：\n声明全局类型：在项目的任何地方都可以使用这些类型，而不需要显式地导入。 为 JavaScript 库提供类型定义：当你使用的库是用 JavaScript 编写的，没有内置的 TypeScript 类型时，你可以通过 .d.ts 文件为其提供类型定义。 扩展现有的模块类型：例如在你的例子中，扩展 Vue Router 的 RouteMeta 接口。 为什么要用 .d.ts 后缀\r明确目的： .d.ts 文件仅包含类型声明，没有具体实现代码。这使得文件的目的非常明确，即它们是用来描述类型结构的。 避免编译： TypeScript 编译器会跳过 .d.ts 文件中的代码，不会将它们编译为 JavaScript。这减少了不必要的编译步骤。 自动合并： TypeScript 会自动合并全局声明文件中的类型信息到项目的类型系统中，这使得这些类型可以在项目的任何地方使用。 实际应用\r在你的项目中创建或修改 router.d.ts 文件，以扩展 RouteMeta 接口，使得访问 meta.title 时不报错：\n创建 router.d.ts 文件： 1 2 3 4 5 6 7 8 9 // src/router.d.ts import \u0026#39;vue-router\u0026#39;; declare module \u0026#39;vue-router\u0026#39; { interface RouteMeta { title?: string; // 你可以在这里添加更多的自定义属性 } } 确保 TypeScript 项目设置：在 tsconfig.json 文件中确保包含了 src 目录，以便 TypeScript 能找到并使用你的声明文件。 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;esnext\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, \u0026#34;strict\u0026#34;: true, \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;] } }, \u0026#34;include\u0026#34;: [\u0026#34;src\u0026#34;] } 使用扩展的类型\r在你的 Vue 3 项目中，你可以安全地访问 meta.title：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { RouteLocationNormalized } from \u0026#39;vue-router\u0026#39;; import { useTagBarStore } from \u0026#39;@/stores/tagBarStore\u0026#39;; function beforeEach(to: RouteLocationNormalized, from: RouteLocationNormalized, next: Function) { const tagBarStore = useTagBarStore(); // 确保 title 存在并且是 string 类型 if (to.meta.title) { tagBarStore.addTag({ name: to.meta.title, path: to.path }); } next(); } 通过这种方式，你可以确保 meta.title 在你的项目中有正确的类型声明，并且在访问时不会报错。\n","date":"2024-08-02T14:09:04+08:00","permalink":"http://localhost:1313/p/ts/","title":"Ts"},{"content":"router-link\r在 Vue Router 中，\u0026lt;router-link\u0026gt; 组件用于创建导航链接。它有多个属性，其中 path 和 query 属性用于指定导航目标和传递查询参数。\n\u0026lt;router-link\u0026gt; 的 to 属性\r\u0026lt;router-link\u0026gt; 使用 to 属性来定义导航目标。to 属性可以是一个字符串或一个对象。\n字符串形式\r当 to 是一个字符串时，它代表路径：\n1 \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; 对象形式\r当 to 是一个对象时，你可以指定路径和查询参数等：\n1 \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/about\u0026#39;, query: { plan: \u0026#39;premium\u0026#39; } }\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; path 和 query 属性详解\rpath 属性\rpath 属性指定导航的目标路径。例如：\n1 \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/about\u0026#39; }\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; query 属性\rquery 属性用于指定查询参数，它是一个对象。例如：\n1 \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/about\u0026#39;, query: { plan: \u0026#39;premium\u0026#39; } }\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; 在这个例子中，生成的 URL 会是 /about?plan=premium。\n示例\r综合使用 path 和 query 属性：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/user\u0026#39;, query: { id: 123, name: \u0026#39;John\u0026#39; } }\u0026#34;\u0026gt;User Profile\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 这个链接会导航到 /user?id=123\u0026amp;name=John。\n完整示例\r下面是一个完整的 Vue 组件示例，展示如何使用 path 和 query 属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Navigation Links\u0026lt;/h1\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/about\u0026#39; }\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/contact\u0026#39;, query: { ref: \u0026#39;newsletter\u0026#39; } }\u0026#34;\u0026gt;Contact\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{ path: \u0026#39;/profile\u0026#39;, query: { user: \u0026#39;john\u0026#39;, age: 30 } }\u0026#34;\u0026gt;Profile\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;App\u0026#39; }; \u0026lt;/script\u0026gt; 总结\r使用 to 属性来定义导航目标，可以是字符串或对象。 使用 path 属性指定目标路径。 使用 query 属性传递查询参数。 通过这些属性，你可以轻松地创建动态导航链接，满足各种导航需求。\n自定义router-link\r通过自定义 router-link 组件，可以实现更多样化的样式和行为控制。你展示的代码片段使用了 custom 属性来定义一个插槽，并手动处理导航行为和样式。\n解释代码片段\rv-bind=\u0026quot;$props\u0026quot;: 传递所有 props 给 router-link。 custom: 启用 custom 模式，使得 router-link 不会自动生成一个 \u0026lt;a\u0026gt; 标签，而是允许你自定义内容。 v-slot=\u0026quot;{ isActive, href, navigate }\u0026quot;: 使用插槽属性接收 isActive（是否处于激活状态）、href（目标链接）和 navigate（导航函数）。 完整示例\r结合你的代码片段，以下是如何将其集成到组件中的完整示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 \u0026lt;template\u0026gt; \u0026lt;el-sub-menu v-if=\u0026#34;item.children \u0026amp;\u0026amp; item.children.length \u0026gt; 0\u0026#34; :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;my-menu-item v-for=\u0026#34;citem in item.children\u0026#34; :item=\u0026#34;citem\u0026#34; :key=\u0026#34;citem.id\u0026#34;\u0026gt;\u0026lt;/my-menu-item\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;router-link v-else v-bind=\u0026#34;$props\u0026#34; custom v-slot=\u0026#34;{ isActive, href, navigate }\u0026#34; \u0026gt; \u0026lt;a v-bind=\u0026#34;$attrs\u0026#34; :href=\u0026#34;href\u0026#34; @click=\u0026#34;navigate\u0026#34; :class=\u0026#34;isActive ? activeClass : inactiveClass\u0026#34; \u0026gt; \u0026lt;el-menu-item :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { MenuItem } from \u0026#34;@/types/component/menuItem\u0026#34;; import { Icon } from \u0026#39;@iconify/vue\u0026#39;; // 使用 defineOptions 关闭 inheritAttrs defineOptions({ inheritAttrs: false, }); // 定义 props const props = defineProps\u0026lt;{ item: MenuItem; }\u0026gt;(); const to = computed(() =\u0026gt; { return props.item.path ? { path: props.item.path } : null; }); // 定义类名 const activeClass = \u0026#39;menu-item-active\u0026#39;; const inactiveClass = \u0026#39;menu-item-inactive\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .no-underline { text-decoration: none; } .menu-item-active { /* 添加激活状态的样式 */ } .menu-item-inactive { /* 添加非激活状态的样式 */ } \u0026lt;/style\u0026gt; 解释\r自定义 router-link: 使用 custom 模式和插槽属性 isActive, href, navigate 自定义内容。 样式处理: 使用 activeClass 和 inactiveClass 定义激活和非激活状态的样式类。 v-bind=\u0026quot;$props\u0026quot; 和 v-bind=\u0026quot;$attrs\u0026quot;: 分别将所有 props 和 attrs 传递给 router-link 和 \u0026lt;a\u0026gt; 标签。 navigate 方法: 确保点击事件正确触发导航。 这种方法允许你完全控制导航行为和样式，同时确保链接行为与 Vue Router 的一致性。\n扩展router-link的props并支持类型限定\r为了在使用 TypeScript 时为 ...RouterLink.props 添加类型限定，你需要在 defineProps 中明确指定属性的类型。可以通过创建一个类型定义并将其与 RouterLink 的属性结合使用来实现。\n实现步骤\r导入 RouterLink 的属性类型。 定义一个包含你希望扩展的属性类型的接口。 结合 RouterLink 的属性类型与自定义属性类型。 示例代码\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { RouterLink, RouterLinkProps } from \u0026#39;vue-router\u0026#39;; import { defineProps } from \u0026#39;vue\u0026#39;; // 定义一个包含 RouterLink 属性和自定义属性的类型 interface CustomRouterLinkProps extends RouterLinkProps { inactiveClass?: string; } // 使用 TypeScript 定义属性 const props = defineProps\u0026lt;CustomRouterLinkProps\u0026gt;(); // 计算属性等逻辑 const to = computed(() =\u0026gt; { return props.to ? { path: props.to as string } : null; }); const activeClass = \u0026#39;menu-item-active\u0026#39;; const inactiveClass = props.inactiveClass || \u0026#39;menu-item-inactive\u0026#39;; \u0026lt;/script\u0026gt; 解释\r导入类型:\n1 import { RouterLink, RouterLinkProps } from \u0026#39;vue-router\u0026#39;; 定义接口:\n1 2 3 interface CustomRouterLinkProps extends RouterLinkProps { inactiveClass?: string; } 在 defineProps 中使用自定义类型:\n1 const props = defineProps\u0026lt;CustomRouterLinkProps\u0026gt;(); 完整示例\r结合你的代码结构，以下是完整的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;template\u0026gt; \u0026lt;el-sub-menu v-if=\u0026#34;item.children \u0026amp;\u0026amp; item.children.length \u0026gt; 0\u0026#34; :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;my-menu-item v-for=\u0026#34;citem in item.children\u0026#34; :item=\u0026#34;citem\u0026#34; :key=\u0026#34;citem.id\u0026#34;\u0026gt;\u0026lt;/my-menu-item\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;router-link v-else v-bind=\u0026#34;$props\u0026#34; custom v-slot=\u0026#34;{ isActive, href, navigate }\u0026#34; \u0026gt; \u0026lt;a v-bind=\u0026#34;$attrs\u0026#34; :href=\u0026#34;href\u0026#34; @click=\u0026#34;navigate\u0026#34; :class=\u0026#34;isActive ? activeClass : inactiveClass\u0026#34; \u0026gt; \u0026lt;el-menu-item :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { RouterLink, RouterLinkProps } from \u0026#39;vue-router\u0026#39;; import { defineProps } from \u0026#39;vue\u0026#39;; import { MenuItem } from \u0026#34;@/types/component/menuItem\u0026#34;; import { Icon } from \u0026#39;@iconify/vue\u0026#39;; // 使用 defineOptions 关闭 inheritAttrs defineOptions({ inheritAttrs: false, }); // 定义一个包含 RouterLink 属性和自定义属性的类型 interface CustomRouterLinkProps extends RouterLinkProps { inactiveClass?: string; } // 使用 TypeScript 定义属性 const props = defineProps\u0026lt;CustomRouterLinkProps\u0026gt;(); // 计算属性等逻辑 const to = computed(() =\u0026gt; { return props.to ? { path: props.to as string } : null; }); const activeClass = \u0026#39;menu-item-active\u0026#39;; const inactiveClass = props.inactiveClass || \u0026#39;menu-item-inactive\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .no-underline { text-decoration: none; } .menu-item-active { /* 添加激活状态的样式 */ } .menu-item-inactive { /* 添加非激活状态的样式 */ } \u0026lt;/style\u0026gt; 总结\r通过导入 RouterLink 的属性类型并创建一个自定义类型接口，你可以在 defineProps 中为扩展属性添加类型限定。这种方法确保了代码的类型安全性和可维护性。\nrouter-link的v-slot属性接收的数据\r在 Vue Router 中，\u0026lt;router-link\u0026gt; 组件使用 v-slot 提供了一些插槽属性，这些属性包含了关于链接状态和导航的有用信息。具体来说，当你使用 custom 属性时，\u0026lt;router-link\u0026gt; 组件会向插槽传递一个对象，该对象包含 isActive, href, 和 navigate 等属性。\n这些属性的数据来源如下：\nisActive: 一个布尔值，指示当前链接是否处于激活状态（即，当前路由是否与该链接匹配）。 href: 生成的链接 URL，基于传递给 to 属性的目标路径。 navigate: 一个方法，用于执行导航操作，当用户点击链接时调用此方法来进行路由导航。 数据传递的过程\r当你在 \u0026lt;router-link\u0026gt; 组件中使用 v-slot 和 custom 属性时，\u0026lt;router-link\u0026gt; 会传递这些插槽属性给你定义的内容。这是 Vue Router 内部实现的一部分，确保你可以完全自定义链接的渲染方式，同时保留路由导航功能。\n代码示例\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;template\u0026gt; \u0026lt;router-link v-else v-bind=\u0026#34;$props\u0026#34; custom v-slot=\u0026#34;{ isActive, href, navigate }\u0026#34; \u0026gt; \u0026lt;a v-bind=\u0026#34;$attrs\u0026#34; :href=\u0026#34;href\u0026#34; @click=\u0026#34;navigate\u0026#34; :class=\u0026#34;isActive ? activeClass : inactiveClass\u0026#34; \u0026gt; \u0026lt;el-menu-item :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { RouterLink, RouterLinkProps } from \u0026#39;vue-router\u0026#39;; import { defineProps } from \u0026#39;vue\u0026#39;; import { MenuItem } from \u0026#34;@/types/component/menuItem\u0026#34;; import { Icon } from \u0026#39;@iconify/vue\u0026#39;; // 使用 defineOptions 关闭 inheritAttrs defineOptions({ inheritAttrs: false, }); // 定义一个包含 RouterLink 属性和自定义属性的类型 interface CustomRouterLinkProps extends RouterLinkProps { inactiveClass?: string; } // 使用 TypeScript 定义属性 const props = defineProps\u0026lt;CustomRouterLinkProps\u0026gt;(); // 计算属性等逻辑 const to = computed(() =\u0026gt; { return props.to ? { path: props.to as string } : null; }); const activeClass = \u0026#39;menu-item-active\u0026#39;; const inactiveClass = props.inactiveClass || \u0026#39;menu-item-inactive\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .no-underline { text-decoration: none; } .menu-item-active { /* 添加激活状态的样式 */ } .menu-item-inactive { /* 添加非激活状态的样式 */ } \u0026lt;/style\u0026gt; 在这个示例中，\u0026lt;router-link\u0026gt; 使用 custom 属性并定义了一个插槽，该插槽接收三个属性：\nisActive: 当前链接是否处于激活状态。 href: 生成的链接 URL。 navigate: 一个方法，用于执行导航。 这些属性是由 Vue Router 的 \u0026lt;router-link\u0026gt; 组件内部传递的。使用这些属性，你可以完全自定义链接的外观和行为，同时确保路由导航功能正常工作。\n总结\r通过 v-slot=\u0026quot;{ isActive, href, navigate }\u0026quot;，你可以从 Vue Router 的 \u0026lt;router-link\u0026gt; 组件中获取到关于链接状态和导航功能的上下文数据。Vue Router 通过 custom 模式提供这些数据，以便你可以灵活地自定义链接的渲染和交互行为。\n","date":"2024-07-31T15:48:34+08:00","permalink":"http://localhost:1313/p/router-link/","title":"Router Link"},{"content":"怎么对文章分类和打标签\r在网站和博客管理中，Tag（标签）和Category（分类）是用于组织和分类内容的两个重要概念，它们有不同的作用和使用方式。\nCategory（分类）\r分类是一种对文章进行层次化管理的方法，通常用于创建内容的大类，帮助用户更容易浏览和找到感兴趣的内容。分类是结构性的，每篇文章通常只会属于一个或少数几个分类。\n例如，你的博客可能有以下分类：\n前端开发 后端开发 项目管理 工具使用 Tag（标签）\r标签是一种更自由、更灵活的内容分类方法，通常用于描述文章的具体内容或主题关键词。标签是扁平结构的，一篇文章可以有多个标签。标签的主要目的是细化分类，帮助用户通过关键词快速找到相关内容。\n例如，对于一篇关于 Vue Router 的文章，你可以使用以下标签：\nVue Router Vue.js 前端框架 路由管理 具体应用举例\r假设你写了一篇关于在某个前端项目中使用 Vue Router 的文章，你可以这样分类和打标签：\nCategory（分类）：前端开发 Tags（标签）：Vue Router, Vue.js, 前端项目, 路由管理 这样，当用户浏览你的博客时，他们可以通过“前端开发”分类找到你的文章，也可以通过点击任何一个标签找到与这些标签相关的其他文章。\n总结\r分类（Category）：用于创建内容的大类，层次化管理，适合为文章进行整体分类。 标签（Tag）：用于描述具体内容或主题关键词，扁平化管理，适合为文章进行细化分类。 希望这些解释对你有所帮助！\n","date":"2024-07-30T10:30:14+08:00","permalink":"http://localhost:1313/p/markdown-%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/","title":"Markdown 写作技巧"},{"content":"API\rrouter.addRoute() 和 router.removeRoute()\r如果新增加的路由与当前位置相匹配，就需要你用 router.push() 或 router.replace() 来手动导航，才能显示该新路由\n并不是说不能使用导航守卫提供的next或return重新导航后不能显示该新路由，而是router.push() 或 router.replace()可以在任何地方使用，不仅限于导航守卫。\nrouter.push() 和 router.replace()\rrouter.push(location)：将路径添加到浏览器的历史记录中，进行导航。\nrouter.replace(location)：替换当前的历史记录条目，而不添加新的条目。\n适用于非导航守卫中的动态导航。\n需要手动控制导航流程。\n可能导致导航守卫不一致（在某些复杂场景下）。\n会重新执行导航守卫\n删除路由\r当路由被删除时，所有的别名和子路由也会被同时删除\n可以通过name删除，所以请保持name值唯一\n添加嵌套路由\r1 2 3 4 5 6 router.addRoute({ name: \u0026#39;admin\u0026#39;, path: \u0026#39;/admin\u0026#39;, component: Admin, children: [{ path: \u0026#39;settings\u0026#39;, component: AdminSettings }], }) 查看现有路由\rVue Router 提供了两个功能来查看现有的路由：\nrouter.hasRoute()：检查路由是否存在。 router.getRoutes()：获取一个包含所有路由记录的数组。 手动导航的三种方式的区别\rrouter.replace() 和 next({ ...to, replace: true })、return { ...to, replace: true }\nrouter.replace() 和 next({ ...to, replace: true }) 在功能上有些相似，但它们的使用场景和细节上有一些区别。\nrouter.replace()\r使用场景：router.replace() 是一个方法，可以在任何地方使用，不仅限于导航守卫。它会立即执行导航，并用新的路由替换当前的路由，而不会在浏览历史中留下记录。 调用位置：可以在组件方法或导航守卫中使用。记住，如果你需要等待新的路由显示，可以使用 await router.replace()。 行为：导航到新的路由并替换当前的路由，旧的路由不会出现在历史记录中。 1 router.replace(\u0026#39;/new-path\u0026#39;); NOTE: 在导航守卫中，更推荐使用next或return来通过返回新的位置来触发重定向\nnext({ ...to, replace: true })\r使用场景：next() 是导航守卫（如 beforeEach）中的特有方法，用于控制导航的过程。next({ ...to, replace: true }) 可以用来重定向并替换当前的路由。 调用位置：只能在导航守卫中使用。 行为：使用 next 方法继续导航过程，并指定重定向目标，同时使用 replace: true 选项来替换当前的路由。 1 2 3 4 5 6 7 router.beforeEach((to, from, next) =\u0026gt; { if (shouldRedirect) { next({ path: \u0026#39;/new-path\u0026#39;, replace: true }); } else { next(); } }); return { ...to, replace: true }\r官网推荐使用return ...替代next(...)\n在导航守卫中，返回一个位置对象会告诉 Vue Router 要导航到新的位置。这个返回值会被 Vue Router 处理，并且重新触发导航守卫，使得整个导航过程重新运行。 自动重新触发导航守卫。 确保新路由生效，并且导航流程一致。 区别\r调用位置：\nrouter.replace() 可以在任何地方调用，包括组件内部的方法、导航守卫等。 next({ ...to, replace: true }) 只能在导航守卫中使用。 导航控制：\nrouter.replace() 是一个独立的方法调用，立即执行导航。 next({ ...to, replace: true }) 是通过导航守卫控制导航流程的一部分。 返回方式：\nrouter.replace() 直接执行，不返回控制权。 next({ ...to, replace: true }) 是在 beforeEach 等导航守卫中用于控制导航流程的返回值。 代码示例\r使用 router.replace()：\n1 2 3 4 5 6 7 router.beforeEach((to, from, next) =\u0026gt; { if (shouldRedirect) { router.replace(\u0026#39;/new-path\u0026#39;); } else { next(); } }); 使用 next({ ...to, replace: true })：\n1 2 3 4 5 router.beforeEach((to, from) =\u0026gt; { if (shouldRedirect) { return { path: \u0026#39;/new-path\u0026#39;, replace: true }; } }); 总结\r在导航守卫中，使用 next({ ...to, replace: true }) 是更推荐的方式，因为它可以更好地控制导航流程。 在导航守卫之外，使用 router.replace()。它是更通用的方法，可以的任何地方使用。 router.addRoute()\rrouter.replace()的应用场景\rrouter.replace ，用于替换当前的路由。这与 router.push 类似，但不同的是，router.replace 不会向历史记录添加新条目，而是替换当前的历史记录条目。因此，当使用 router.replace 进行导航时，用户无法通过点击浏览器的“返回”按钮回到先前的页面。\n以下是一些使用 router.replace 的典型场景：\n登录和注销重定向： 当用户登录成功后，你可能希望将用户重定向到首页或特定的仪表盘页面，并且不希望用户通过浏览器的“返回”按钮回到登录页面。\n1 2 // 登录成功后的处理 this.$router.replace({ name: \u0026#39;dashboard\u0026#39; }); 清理查询参数： 如果用户通过带有查询参数的链接访问某个页面，但在页面加载后这些查询参数已经不再需要，可以使用 router.replace 清理 URL。\n1 2 3 4 if (this.$route.query.token) { // 处理 token... this.$router.replace({ path: this.$route.path, query: null }); } 表单提交后的重定向： 在表单提交成功后，通常会将用户重定向到一个新页面。为了避免用户通过“返回”按钮重新提交表单，可以使用 router.replace。\n1 2 3 this.submitForm().then(() =\u0026gt; { this.$router.replace({ name: \u0026#39;successPage\u0026#39; }); }); 404 页面重定向： 当用户访问一个不存在的页面时，可以将用户重定向到 404 页面，并使用 router.replace 以防止用户在返回时再次看到错误页面。\n1 2 3 4 // 在路由守卫或组件中 if (this.pageNotFound) { this.$router.replace({ name: \u0026#39;NotFound\u0026#39; }); } 基于条件的动态重定向： 在某些情况下，你可能会基于条件来重定向用户。例如，用户访问某个特定页面时，根据用户角色或权限进行重定向。\n1 2 3 if (userRole !== \u0026#39;admin\u0026#39;) { this.$router.replace({ name: \u0026#39;home\u0026#39; }); } NOTE： 在导航守卫中更推荐return ...或next(...)\n示例代码\r1 2 3 4 5 6 7 8 9 10 11 12 // 在 Vue 组件中使用 export default { methods: { login() { // 模拟登录请求 setTimeout(() =\u0026gt; { // 登录成功后重定向到 dashboard 页面 this.$router.replace({ name: \u0026#39;dashboard\u0026#39; }); }, 1000); } } } 总之router.replace 它在防止用户回到不希望显示的页面时非常有用。\n动态调整应用的路由结构\r在 Vue Router 的导航守卫中动态添加或删除路由是一个比较高级的用法，通常在需要基于某些条件（例如用户权限或角色）动态调整应用的路由结构时使用。\n这个场景的核心思想是，导航守卫可以在导航过程中对路由进行修改，然后通过返回一个新的位置来触发重定向，而不是直接调用 router.replace()。这是因为在导航守卫中直接调用 router.replace() 可能会导致导航重复触发，从而引起无限循环的问题。\n示例场景解释\r假设我们有一个应用，其中某些路由只有在特定条件下才存在（例如，用户登录后才可访问的管理页面）。在用户访问某个路由时，我们需要检查该路由是否已经存在，如果不存在则动态添加，然后重定向到该路由。\n代码示例\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 导航守卫中动态添加路由 router.beforeEach(async (to, from, next) =\u0026gt; { // 判断目标路由是否存在 if (!hasNecessaryRoute(to)) { // 动态生成并添加路由 const newRoute = generateRoute(to) router.addRoute(newRoute) // 返回新的位置以触发重定向 next({ ...to, replace: true }) } else { // 正常导航 next() } }) // 判断目标路由是否已经存在 function hasNecessaryRoute(to) { return router.getRoutes().some(route =\u0026gt; route.name === to.name) } // 根据目标路由动态生成新的路由 function generateRoute(to) { // 示例：根据目标路由生成新路由 return { path: to.path, name: to.name, component: () =\u0026gt; import(`@/views/${to.name}.vue`) } } 详细解释\r检查路由是否存在： 在导航守卫中首先检查目标路由是否已经存在，使用 router.getRoutes() 获取当前所有路由，然后通过 some 方法判断目标路由是否存在。\n动态添加路由： 如果目标路由不存在，则通过 generateRoute(to) 动态生成新的路由配置，并使用 router.addRoute() 将新路由添加到路由表中。\n触发重定向： 通过返回新的位置（即 next({ ...to, replace: true })）来触发重定向。这将确保当前导航被取消，然后重新发起一次导航到新的路由，同时使用 replace: true 确保不会向浏览器的历史记录添加新条目。\n正常导航： 如果目标路由已经存在，则调用 next() 进行正常导航。\n注意事项\r避免无限循环： 通过返回新的位置触发重定向，而不是直接调用 router.replace()，可以有效避免导航守卫中的无限循环问题。 异步加载组件： 动态添加的路由可以使用异步组件加载，以确保在路由被访问时组件才会被加载，优化应用性能。 通过这种方式，可以在导航过程中根据实际需要动态调整路由结构，确保用户始终能够访问到最新的路由配置。\nrouter.replace()理解如何通过返回新的位置触发重定向而避免无限循环问题，可以从 Vue Router 的导航守卫执行逻辑入手。\r导航守卫中的无限循环问题\r在导航守卫中直接调用 router.replace() 可能会导致无限循环。这是因为 router.replace() 会立即触发一次新的导航，而这个新的导航会再次触发导航守卫，导致导航守卫再次执行 router.replace()，从而形成无限循环。\n通过返回新的位置避免无限循环\r当我们在导航守卫中返回新的位置而不是直接调用 router.replace() 时，Vue Router 会认为这是一次新的导航请求。这个新的导航请求会重新评估所有导航守卫，但因为我们在返回新的位置时不会立即触发导航（而是等待当前导航流程完成），所以不会形成无限循环。\n代码解析\r下面是一个具体的代码示例以及解析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 导航守卫中动态添加路由 router.beforeEach(async (to, from, next) =\u0026gt; { // 判断目标路由是否存在 if (!hasNecessaryRoute(to)) { // 动态生成并添加路由 const newRoute = generateRoute(to) router.addRoute(newRoute) // 返回新的位置以触发重定向，避免直接调用 router.replace() next({ ...to, replace: true }) } else { // 正常导航 next() } }) // 判断目标路由是否已经存在 function hasNecessaryRoute(to) { return router.getRoutes().some(route =\u0026gt; route.name === to.name) } // 根据目标路由动态生成新的路由 function generateRoute(to) { // 示例：根据目标路由生成新路由 return { path: to.path, name: to.name, component: () =\u0026gt; import(`@/views/${to.name}.vue`) } } 详细解析\r判断目标路由是否存在：\n使用 router.getRoutes() 获取当前所有路由，并通过 some 方法判断目标路由是否存在。 动态添加路由：\n如果目标路由不存在，使用 generateRoute(to) 动态生成新的路由配置，并使用 router.addRoute(newRoute) 将新路由添加到路由表中。 返回新的位置：\n通过 next({ ...to, replace: true }) 返回新的位置。这告诉 Vue Router 当前导航已经结束，并需要导航到新的位置。 replace: true 确保不会向浏览器的历史记录添加新条目。 重新触发导航守卫：\n返回新的位置后，Vue Router 会重新评估导航守卫。但由于我们不是立即触发导航，而是等待当前导航流程完成，所以不会出现无限循环问题。 正常导航：\n如果目标路由已经存在，直接调用 next() 进行正常导航。 避免无限循环的关键点\r等待当前导航流程完成： 返回新的位置而不是立即调用 router.replace() 允许当前的导航流程完成后再触发新的导航。这避免了直接在导航守卫中嵌套触发新的导航请求，避免了无限循环。\n返回新的位置： 返回新的位置通过 next({ ...to, replace: true }) 告诉 Vue Router 重定向到新的位置，而不是立即发起一个新的导航请求。这样可以确保新的导航流程在当前流程完成后才会开始。\n通过这种方式，可以动态调整路由配置，同时避免导航守卫中的无限循环问题。无限循环问题\n路由记录和元信息\rVue Router 的标准路由记录和 meta 类型是设计用来管理和配置路由信息的。这些设计使得在应用中处理路由变得更加灵活和强大。以下是对 Vue Router 的标准路由记录和 meta 类型的详细说明：\n标准路由记录类型 (RouteRecordRaw)\rRouteRecordRaw 是 Vue Router 中定义路由的基本类型。它用于定义一个路由配置的原始记录。主要字段包括：\npath: string\n路由的路径。可以是静态路径或者带有动态参数的路径（例如 /user/:id）。 name: string | undefined\n路由的名称。这个名称用于路由导航和重定向。它可以是 undefined。 component: Component | AsyncComponent | undefined\n这个路由匹配时加载的组件。可以是一个组件对象，也可以是异步组件加载函数。 redirect: string | Location | Function | undefined\n路由重定向的目标路径。如果设置了重定向，当访问这个路由时，会自动导航到指定的目标路径。 children: RouteRecordRaw[] | undefined\n子路由配置。这个路由的子路由配置可以通过嵌套的 RouteRecordRaw 数组来定义。如果没有子路由，这个字段可以是 undefined。 meta: Record\u0026lt;string, any\u0026gt;\n路由的元信息。meta 是一个对象，可以包含任意的自定义信息，比如权限、标题等。这些信息不会影响路由的匹配，而是用于应用的其他逻辑。 beforeEnter: RouteEnterGuard | undefined\n进入路由前的导航守卫函数。用于在路由进入前进行权限检查或其他逻辑处理。 props: boolean | object | Function | undefined\n控制如何将路由参数传递给组件。可以是布尔值、对象、函数或者 undefined。 meta 类型\rmeta 是路由记录中的一个字段，用于存储与路由相关的任意元数据。你可以根据需要自定义 meta 的内容。常见的字段包括：\ntitle: string | undefined\n路由的标题，通常用于页面标题或面包屑导航。 requiresAuth: boolean | undefined\n是否需要认证。用于控制访问权限，比如只有经过认证的用户才能访问该路由。 roles: string[] | undefined\n访问该路由需要的角色列表。用于权限控制。 icon: string | undefined\n路由的图标。通常用于侧边栏或导航菜单。 hidden: boolean | undefined\n是否在导航菜单中隐藏该路由。 keepAlive: boolean | undefined\n是否缓存该路由组件。通常用于优化性能，避免重复加载组件。 alwaysShow: boolean | undefined\n在多级路由中，是否始终显示该路由的父级菜单。 activePath: string | undefined\n用于设置路由激活状态的路径，通常用于动态高亮菜单项。 showLink: boolean | undefined\n是否在导航菜单中显示该路由。 示例\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { RouteRecordRaw } from \u0026#39;vue-router\u0026#39;; const routes: Array\u0026lt;RouteRecordRaw\u0026gt; = [ { path: \u0026#39;/home\u0026#39;, name: \u0026#39;Home\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/Home.vue\u0026#39;), meta: { title: \u0026#39;Home Page\u0026#39;, requiresAuth: false, icon: \u0026#39;home\u0026#39;, hidden: false, }, }, { path: \u0026#39;/profile\u0026#39;, name: \u0026#39;Profile\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/Profile.vue\u0026#39;), meta: { title: \u0026#39;User Profile\u0026#39;, requiresAuth: true, icon: \u0026#39;user\u0026#39;, hidden: false, }, children: [ { path: \u0026#39;settings\u0026#39;, name: \u0026#39;ProfileSettings\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/ProfileSettings.vue\u0026#39;), meta: { title: \u0026#39;Profile Settings\u0026#39;, requiresAuth: true, icon: \u0026#39;settings\u0026#39;, }, }, ], }, ]; 总结\rRouteRecordRaw 类型定义了一个路由记录的基本结构，包括路径、名称、组件、重定向、子路由、元信息等。 meta 字段用于存储与路由相关的任意元数据，方便应用进行各种自定义配置和逻辑处理。 懒加载不使用defineAsyncComponent\r根据警告信息，Vue Router 建议使用懒加载组件时直接传递 import 语句，而不是使用 defineAsyncComponent。这是因为 Vue Router 内部会处理组件的懒加载逻辑，因此不需要在外部包装一层 defineAsyncComponent。\n修改代码\r将 defineAsyncComponent 替换为直接使用 import 语句即可。\n修改前\r假设你在路由配置中使用 defineAsyncComponent，代码可能如下：\n1 2 3 4 5 6 7 8 9 import { defineAsyncComponent } from \u0026#39;vue\u0026#39;; const routes = [ { path: \u0026#39;/system/menu\u0026#39;, component: defineAsyncComponent(() =\u0026gt; import(\u0026#39;@/views/system/menu.vue\u0026#39;)), }, // 其他路由 ]; 修改后\r将 defineAsyncComponent 替换为直接使用 import：\n1 2 3 4 5 6 7 const routes = [ { path: \u0026#39;/system/menu\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/system/menu.vue\u0026#39;), }, // 其他路由 ]; 示例\r下面是一个完整的路由配置文件示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39;; const routes = [ { path: \u0026#39;/system/menu\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/system/menu.vue\u0026#39;), }, // 其他路由 ]; const router = createRouter({ history: createWebHistory(), routes, }); export default router; 总结\r将 defineAsyncComponent 替换为直接使用 import 语句以避免警告，并简化路由配置。这样可以更好地遵循 Vue Router 的建议和最佳实践。\n动态导入组件\r使用 import.meta.glob 是处理动态导入的一个有效方法，它可以在构建时自动解析和加载匹配的模块。这种方式是 Vite 提供的，用于处理动态模块导入，支持静态分析和构建优化。它适用于你需要根据路径动态加载组件的情况。\n使用 import.meta.glob\r示例代码\r定义和使用动态模块导入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // utils.ts import { log } from \u0026#34;@/plugins/logger\u0026#34;; import { MenuItem } from \u0026#34;@/types/component/menuItem\u0026#34;; import { RouteRecordRaw } from \u0026#34;vue-router\u0026#34;; // 使用 import.meta.glob 加载所有 Vue 组件 const modules = import.meta.glob(\u0026#39;@/views/**/*.vue\u0026#39;); // 根据路径加载组件 function loadComponent(componentPath: string) { const path = `@/views/${componentPath}`; if (modules[path]) { return modules[path]; } else { return () =\u0026gt; Promise.reject(\u0026#39;Component not found\u0026#39;); } } // 转换 MenuItem 到 RouteRecordRaw function convertToRoute(menuItem: MenuItem): RouteRecordRaw { const route: RouteRecordRaw = { path: menuItem.path, name: menuItem.name, component: menuItem.component ? loadComponent(menuItem.component) : undefined, redirect: menuItem.redirect, meta: menuItem.meta as Record\u0026lt;string, any\u0026gt;, // 递归调用convertToRoute children: menuItem.children ? menuItem.children.map(convertToRoute) : [] }; return route; } // 遍历路由数据并添加到 router export function addRoutes(menus: MenuItem[]) { menus.forEach((menuItem) =\u0026gt; { const route = convertToRoute(menuItem); if (route.name \u0026amp;\u0026amp; !router.hasRoute(route.name)) { router.addRoute(route); log(\u0026#34;动态添加路由: name= %s, path= %s\u0026#34;, route.name, route.path); } }); } 说明\rimport.meta.glob：这个方法会返回一个包含匹配文件的对象，键是文件路径，值是一个函数，这个函数会返回一个动态导入的 Promise。 loadComponent 函数：通过检查 modules 对象中是否包含指定路径来动态加载组件。如果路径存在于 modules 中，它将返回对应的模块，否则返回一个拒绝的 Promise。 注意事项\r路径匹配： 确保 import.meta.glob 中的路径匹配模式正确。@/views/**/*.vue 匹配 src/views 目录下的所有 Vue 文件及其子目录。\n路径映射： 路径应与 import.meta.glob 中定义的匹配模式一致。@/views/${componentPath} 应该和实际路径匹配。\n组件导入： 确保 modules 中定义的路径与实际组件路径一致，否则会导致找不到组件。\n构建优化： import.meta.glob 在构建时会优化模块加载，避免在运行时解析路径。\n通过这种方式，你可以在运行时动态加载和注册 Vue 组件，适合于需要动态导入大量组件的场景。\n","date":"2024-07-26T16:53:32+08:00","permalink":"http://localhost:1313/p/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8/","title":"动态路由使用"},{"content":"参考资料\relement-icon、svg-icon、@iconify/vue三种图标方案对比 ","date":"2024-07-26T13:58:44+08:00","permalink":"http://localhost:1313/p/%E5%9B%BE%E6%A0%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","title":"图标解决方案"},{"content":"安装依赖\r1 pnpm add -D @iconify/vue 基本使用\r1 2 3 4 5 6 \u0026lt;template\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { Icon } from \u0026#39;@iconify/vue\u0026#39;; \u0026lt;/script\u0026gt; ps: 官方使用示例\n","date":"2024-07-26T13:30:58+08:00","permalink":"http://localhost:1313/p/iconify%E5%9B%BE%E6%A0%87%E4%BD%BF%E7%94%A8/","title":"Iconify图标使用"},{"content":"往组件传递数据\r在 Vue 3 中，使用 defineProps 来定义组件的 props 时，有两种主要方式：\n使用 defineProps({ item: Object })： 这种方式直接定义 props 为一个对象，其中 item 是 Object 类型。这种方法比较灵活，适用于不需要精确定义 props 类型的情况。\n使用 defineProps(['itemData'])： 这种方式仅指定 props 的名称，而不指定其类型或结构。这种方法适用于简单的情况，尤其是当你不关心 props 的类型时。\n区别与选择\r类型定义\ndefineProps({ item: Object })：明确指定 item 为 Object 类型，适用于需要定义类型的情况，但类型定义较为宽泛。 defineProps(['itemData'])：只定义 props 名称，Vue 自动推断类型，类型推断更为宽泛，不适合严格的类型检查。 TypeScript 支持\ndefineProps({ item: Object })：在 TypeScript 项目中，可以使用类型来增强类型检查和代码提示。 defineProps(['itemData'])：无法提供类型检查和代码提示，对于复杂项目或需要类型安全的项目不太适用。 选择\r如果你需要在 TypeScript 项目中保持类型安全和代码提示，使用 defineProps 并明确指定类型是更好的选择。 如果你不需要类型检查，或者项目较小、简单，使用 defineProps(['itemData']) 也是一种简洁的选择。 示例代码\r使用 defineProps({ item: Object })\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 使用传递过来的 item 值 --\u0026gt; \u0026lt;span\u0026gt;{{ item.name }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { defineProps } from \u0026#39;vue\u0026#39;; // 定义 props 接收 item const props = defineProps({ item: Object }); \u0026lt;/script\u0026gt; 使用 defineProps(['itemData'])\r1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 使用传递过来的 itemData 值 --\u0026gt; \u0026lt;span\u0026gt;{{ itemData.name }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { defineProps } from \u0026#39;vue\u0026#39;; // 定义 props 接收 itemData const props = defineProps([\u0026#39;itemData\u0026#39;]); \u0026lt;/script\u0026gt; 在这个例子中，itemData 是从父组件传递的 prop。这两种方法的选择取决于你对类型安全和代码提示的需求。\ndefineOptions({ inheritAttrs: false })\rdefineOptions 是 Vue 3.3 引入的一个功能，用于在 \u0026lt;script setup\u0026gt; 中定义组件选项。inheritAttrs 属性决定了是否将未被组件 props 接受的属性自动应用到组件的根元素上。\n当你设置 inheritAttrs: false 时，未被接受的属性不会自动应用到组件的根元素上，你需要手动处理这些属性。这样可以更精细地控制组件的行为和样式。 自动继承: 默认情况下，未声明的属性会自动添加到组件的根元素上。 控制传递: 可以使用 inheritAttrs: false 来禁用这种默认行为，并通过 $attrs 手动控制这些属性的传递。\n在你的上下文中，defineOptions({ inheritAttrs: false }) 的使用可以防止未定义的属性传递到 \u0026lt;router-link\u0026gt; 和 \u0026lt;el-menu-item\u0026gt;，从而避免潜在的样式或行为问题。\n改进的完整示例\r结合 defineOptions 和前面解决下划线问题的建议，这里是一个改进的完整示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;template\u0026gt; \u0026lt;!-- 有子节点：展示item标题，并递归item.children --\u0026gt; \u0026lt;el-sub-menu v-if=\u0026#34;item.children \u0026amp;\u0026amp; item.children.length \u0026gt; 0\u0026#34; :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;my-menu-item v-for=\u0026#34;citem in item.children\u0026#34; :item=\u0026#34;citem\u0026#34; :key=\u0026#34;citem.id\u0026#34;\u0026gt;\u0026lt;/my-menu-item\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;!-- 没有子节点，展示item本身 --\u0026gt; \u0026lt;router-link :to=\u0026#34;to\u0026#34; class=\u0026#34;no-underline\u0026#34;\u0026gt; \u0026lt;el-menu-item v-if=\u0026#34;!item.children || item.children.length === 0\u0026#34; :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { MenuItem } from \u0026#34;@/types/component/menuItem\u0026#34;; import { Icon } from \u0026#39;@iconify/vue\u0026#39;; // 使用 defineOptions 关闭 inheritAttrs defineOptions({ inheritAttrs: false, }); // 定义 props const props = defineProps\u0026lt;{ item: MenuItem; }\u0026gt;(); const to = computed(() =\u0026gt; { return props.item.path ? { path: props.item.path } : null; }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .no-underline { text-decoration: none; } \u0026lt;/style\u0026gt; 解释\rdefineOptions({ inheritAttrs: false }): 关闭 inheritAttrs，确保未定义的属性不会自动应用到组件的根元素上。这样可以更精细地控制属性的传递。 to 计算属性: 确保 to 始终有一个有效值或为 null。 样式处理: 添加 no-underline 类以移除下划线。 这种方法确保了你的菜单项在没有子节点时不会显示下划线，同时也使得属性的传递和处理更加明确。\n$props和$attr\r在 Vue 中，$props 和 $attrs 是两个特殊的对象，用于处理组件的属性传递和未被接收的属性。\n$props\r$props 是一个对象，包含当前组件的所有 props。当你使用 v-bind=\u0026quot;$props\u0026quot; 时，实际上是将当前组件接收到的所有 props 传递给子组件。这在需要将所有接收到的 props 原样传递给另一个组件时非常有用。\n$attrs\r$attrs 是一个对象，包含父组件传递但未被当前组件显式接收（通过 props 定义）的所有 attribute。这些 attributes 会被自动添加到当前组件的根元素上，除非使用 inheritAttrs: false 禁用这种行为。通过 v-bind=\u0026quot;$attrs\u0026quot; 可以将这些属性传递给子组件或元素。\n结合使用 $props 和 $attrs\r在你的示例中，使用 v-bind=\u0026quot;$props\u0026quot; 和 v-bind=\u0026quot;$attrs\u0026quot; 可以确保所有传递给当前组件的属性和 props 都能被正确地传递到嵌套的子组件中。这在封装组件时特别有用，可以避免重复定义和手动传递属性。\n示例解释\r假设我们有一个 MyMenuItem 组件，并希望将所有传递给它的 props 和未被显式接收的 attributes 传递给内部的 \u0026lt;router-link\u0026gt; 和 \u0026lt;a\u0026gt; 元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;template\u0026gt; \u0026lt;!-- 处理有子节点的情况 --\u0026gt; \u0026lt;el-sub-menu v-if=\u0026#34;item.children \u0026amp;\u0026amp; item.children.length \u0026gt; 0\u0026#34; :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;my-menu-item v-for=\u0026#34;citem in item.children\u0026#34; :item=\u0026#34;citem\u0026#34; :key=\u0026#34;citem.id\u0026#34;\u0026gt;\u0026lt;/my-menu-item\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;!-- 处理没有子节点的情况 --\u0026gt; \u0026lt;router-link v-else v-bind=\u0026#34;$props\u0026#34; custom v-slot=\u0026#34;{ isActive, href, navigate }\u0026#34; \u0026gt; \u0026lt;a v-bind=\u0026#34;$attrs\u0026#34; :href=\u0026#34;href\u0026#34; @click=\u0026#34;navigate\u0026#34; :class=\u0026#34;isActive ? activeClass : inactiveClass\u0026#34; \u0026gt; \u0026lt;el-menu-item :index=\u0026#34;String(item.id)\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;Icon :icon=\u0026#34;item.meta.icon\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ item.meta.title }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/router-link\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { MenuItem } from \u0026#34;@/types/component/menuItem\u0026#34;; import { Icon } from \u0026#39;@iconify/vue\u0026#39;; // 使用 defineOptions 关闭 inheritAttrs defineOptions({ inheritAttrs: false, }); // 定义 props const props = defineProps\u0026lt;{ item: MenuItem; }\u0026gt;(); const to = computed(() =\u0026gt; { return props.item.path ? { path: props.item.path } : null; }); // 定义类名 const activeClass = \u0026#39;menu-item-active\u0026#39;; const inactiveClass = \u0026#39;menu-item-inactive\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .no-underline { text-decoration: none; } .menu-item-active { /* 添加激活状态的样式 */ } .menu-item-inactive { /* 添加非激活状态的样式 */ } \u0026lt;/style\u0026gt; 解释\rv-bind=\u0026quot;$props\u0026quot;: 将 MyMenuItem 组件接收到的所有 props 传递给 \u0026lt;router-link\u0026gt;。 v-bind=\u0026quot;$attrs\u0026quot;: 将未被 MyMenuItem 组件显式接收的 attributes 传递给 \u0026lt;a\u0026gt; 标签。 inheritAttrs: false: 禁用将未被显式接收的 attributes 自动添加到组件根元素的默认行为，确保手动控制这些 attributes 的传递。 这种方法确保了属性的传递和行为的一致性，同时简化了代码的维护和可读性。\nprops和attrs的区别\rprops 和 attrs 在 Vue 中都有属性传递的功能，但它们有不同的用途和行为。\nprops\r定义: props 是组件显式声明的属性，用于从父组件传递数据到子组件。 作用: 组件通过 props 接收父组件传递的数据，并且可以在组件内使用这些数据。 类型检查: props 可以进行类型检查和默认值设置。 示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;child-component :message=\u0026#34;parentMessage\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ message }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const props = defineProps({ message: String }); \u0026lt;/script\u0026gt; 在这个示例中，ChildComponent 声明了一个 message prop，从父组件接收 parentMessage 的值。\nattrs\r定义: attrs 是父组件传递但未在子组件中显式声明为 props 的属性。 作用: attrs 通常用于将任意的、未声明的属性传递给组件的根元素或子元素。 自动继承: 默认情况下，未声明的属性会自动添加到组件的根元素上。 控制传递: 可以使用 inheritAttrs: false 来禁用这种默认行为，并通过 $attrs 手动控制这些属性的传递。 示例: 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;child-component custom-attr=\u0026#34;someValue\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div v-bind=\u0026#34;$attrs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; defineOptions({ inheritAttrs: false }); \u0026lt;/script\u0026gt; 在这个示例中，ChildComponent 没有声明 custom-attr 作为 props，因此它会被自动添加到组件的根元素上（除非使用 inheritAttrs: false）。\n区别总结\r声明方式:\nprops 是显式声明的属性，用于传递特定的数据。 attrs 是未显式声明的属性，用于传递任意的、额外的属性。 类型检查和默认值:\nprops 可以进行类型检查和默认值设置。 attrs 不支持类型检查和默认值设置。 传递方式:\nprops 需要在子组件中显式声明。 attrs 是自动传递的，但可以使用 inheritAttrs: false 来手动控制。 使用示例\r以下是一个更详细的示例，展示如何使用 props 和 attrs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;child-component :message=\u0026#34;parentMessage\u0026#34; custom-attr=\u0026#34;someValue\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const parentMessage = \u0026#39;Hello from parent\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 使用 props --\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;!-- 使用 attrs --\u0026gt; \u0026lt;div v-bind=\u0026#34;$attrs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; defineOptions({ inheritAttrs: false }); const props = defineProps({ message: String }); \u0026lt;/script\u0026gt; 在这个示例中，ChildComponent 显式声明了一个 message prop 来接收父组件的数据，并通过 v-bind=\u0026quot;$attrs\u0026quot; 将未声明的 custom-attr 属性传递给内部的 div 元素。\n","date":"2024-07-25T16:33:25+08:00","permalink":"http://localhost:1313/p/vue3%E4%BD%BF%E7%94%A8/","title":"Vue3使用"},{"content":"注意事项\r所有涉及菜单的组件，都需要传index属性，否则不会正常展示 MyMenuItem.vue组件的实现\ritem 没有子节点：直接使用el-menu-item展示item本身 item 有子节点： 使用el-sub-menu item.meta.title作为标题 递归MyMenuItem.vue组件对item.children属性遍历 图标使用\riconify\n点击菜单跳转路由\rel-menu\rdefault-active\r页面加载时默认激活菜单的 index\nel-sub-menu\r标题\rindex属性\r唯一标志，必填\n自定义外部 \u0026amp; 内部链接组件\r这个组件定义了一个名为 AppLink 的动态链接组件，根据 props.to 的值决定渲染成外部链接 \u0026lt;a\u0026gt; 还是内部路由链接 \u0026lt;router-link\u0026gt;。\n让我们逐步解析：\n模板部分 (\u0026lt;template\u0026gt;):\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;component :is=\u0026#34;linkType\u0026#34; v-bind=\u0026#34;linkProps(to)\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/component\u0026gt; \u0026lt;/template\u0026gt; component 组件根据 linkType 动态地渲染为 linkType 的值，可以是 \u0026quot;a\u0026quot; 或 \u0026quot;router-link\u0026quot;。 v-bind=\u0026quot;linkProps(to)\u0026quot; 将 linkProps 函数返回的属性动态绑定到 component 组件上。 \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; 用于插入组件的内容。 设置部分 (\u0026lt;script setup lang=\u0026quot;ts\u0026quot;\u0026gt;):\ndefineOptions 用于定义组件选项，这里设置了组件的名称为 \u0026quot;AppLink\u0026quot;，并且禁用了继承的属性绑定（inheritAttrs: false）。\n导入与计算属性:\nimport { isExternal } from \u0026quot;@/utils/index\u0026quot;; 导入了一个名为 isExternal 的工具函数。 defineProps 定义了组件的属性 to，类型为 Object，且必需。 computed 属性 isExternalLink 根据 props.to.path 的值来判断是否为外部链接。 计算属性与函数:\nisExternalLink 是一个计算属性，根据 props.to.path 是否为空或者属于外部链接，决定返回 true 或 false。 linkType 是一个计算属性，根据 isExternalLink 的值决定返回 \u0026quot;a\u0026quot; 或 \u0026quot;router-link\u0026quot;，从而确定要渲染的具体的 HTML 元素类型。 linkProps 是一个函数，接收一个 to 参数，根据 isExternalLink 的值返回相应的属性对象，用于 \u0026lt;a\u0026gt; 或 \u0026lt;router-link\u0026gt; 的设置。 综上所述，这个组件根据传入的 to 属性值，动态地决定是渲染成外部链接 \u0026lt;a\u0026gt; 还是内部路由链接 \u0026lt;router-link\u0026gt;，并根据这个决定设置相应的属性。\n","date":"2024-07-25T14:57:35+08:00","permalink":"http://localhost:1313/p/%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%AE%9E%E7%8E%B0/","title":"菜单栏实现"},{"content":"持久化\r目前暂时没有持久化的必要！！！\n从你提供的日志来看，刷新页面后，Pinia Store 的状态似乎被重置了。这通常是因为在刷新页面时，应用的 JavaScript 会重新加载，导致状态存储在内存中的 Store 数据丢失。为了保持登录状态和其他用户信息，通常会将一些关键数据存储在持久化存储中（例如 localStorage 或 sessionStorage），并在应用重新加载时从存储中恢复这些数据。\n可以使用 pinia-plugin-persist 插件来实现这一功能。以下是如何设置和使用 pinia-plugin-persist 的步骤：\n1. 安装 pinia-plugin-persist\r首先，你需要安装 pinia-plugin-persist：\n1 npm install pinia-plugin-persist 2. 配置 pinia-plugin-persist\r在你的 Pinia 配置中添加这个插件：\n1 2 3 4 5 6 7 import { createPinia } from \u0026#39;pinia\u0026#39;; import piniaPluginPersist from \u0026#39;pinia-plugin-persist\u0026#39;; const pinia = createPinia(); pinia.use(piniaPluginPersist); export default pinia; 3. 更新 userStore 以启用持久化\r在你的 userStore 中启用持久化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { defineStore } from \u0026#39;pinia\u0026#39;; export const useUserStore = defineStore({ id: \u0026#39;userStore\u0026#39;, state: () =\u0026gt; ({ roles: [] as string[], permissions: [] as string[], hasInitDynamicRoute: false, }), actions: { async getUserProfile() { const data = await userApi.getUserProfile(); this.roles = data.roles; this.permissions = data.permissions; }, setHasInitDynamicRoute() { this.hasInitDynamicRoute = true; }, resetDynamicRoute() { this.hasInitDynamicRoute = false; }, logout() { this.resetDynamicRoute(); this.roles = []; this.permissions = []; localStorage.removeItem(APP_TOKEN_KEY); } }, persist: { enabled: true, strategies: [ { key: \u0026#39;userStore\u0026#39;, storage: localStorage, } ] } }); 4. 初始化 Pinia 并挂载到 Vue 应用\r在你的 main.ts 或 main.js 文件中初始化 Pinia 并挂载到 Vue 应用：\n1 2 3 4 5 6 7 8 9 10 11 import { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import router from \u0026#39;./router\u0026#39;; import pinia from \u0026#39;./stores\u0026#39;; // 确保引入的是配置了持久化插件的 pinia 实例 const app = createApp(App); app.use(router); app.use(pinia); app.mount(\u0026#39;#app\u0026#39;); 5. 确保在导航守卫中处理持久化数据\r在导航守卫中，确保从 Store 中获取用户数据和权限：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import { APP_TOKEN_KEY } from \u0026#39;@/enums/AppConfigEnum\u0026#39;; import { log } from \u0026#39;@/plugins/logger\u0026#39;; import router from \u0026#39;@/router\u0026#39;; import { useUserStore } from \u0026#39;@/store/userStore\u0026#39;; import { RouteLocationNormalized } from \u0026#39;vue-router\u0026#39;; export function configDynamicRouting() { router.beforeEach(async (to: RouteLocationNormalized, from: RouteLocationNormalized) =\u0026gt; { log(\u0026#39;to.path=%s, to.fullPath=%s, to.hash=, to.matched=%s, to.meta=%s, to.name=%s, to.params=%s, to.query=%s, to.redirectedFrom=%s,\u0026#39;, to.path, to.fullPath, to.hash, to.matched, to.meta, to.name, to.params, to.query, to.redirectedFrom); log(\u0026#39;from.path=%s, from.fullPath=%s, from.hash=, from.matched=%s, from.meta=%s, from.name=%s, from.params=%s, from.query=%s, from.redirectedFrom=%s,\u0026#39;, from.path, from.fullPath, from.hash, from.matched, from.meta, from.name, from.params, from.query, from.redirectedFrom); const token = localStorage.getItem(APP_TOKEN_KEY); if (!token) { if (to.name === \u0026#39;Login\u0026#39;) { log(\u0026#34;未登录，访问登录页\u0026#34;); return true; } else if (to.matched.length !== 0) { log(\u0026#34;未登录，访问其它页 + 匹配成功, to.matched.length=%s\u0026#34;, to.matched.length); return { name: \u0026#39;Login\u0026#39; }; } else if (to.matched.length === 0) { log(\u0026#34;未登录，访问其它页 + 匹配失败\u0026#34;); return { name: \u0026#39;404\u0026#39; }; } } else { log(\u0026#34;已登录....\u0026#34;); const userStore = useUserStore(); const { hasInitDynamicRoute, roles, permissions } = storeToRefs(userStore); if (to.name === \u0026#39;Login\u0026#39;) { if (hasInitDynamicRoute.value) { log(\u0026#34;已登录 + 已初始化动态路由，访问登录页\u0026#34;); return { path: \u0026#39;/\u0026#39; }; } } if (!permissions.value.length) { log(\u0026#34;已登录 + 权限缓存为空\u0026#34;); try { await userStore.getUserProfile(); userStore.setHasInitDynamicRoute(); } catch (error) { log(\u0026#34;error %s\u0026#34;, error); return { name: \u0026#39;Login\u0026#39; }; } return { ...to, replace: true }; } else if (!hasInitDynamicRoute.value) { log(\u0026#34;已登录 + 权限缓存有值 + 未设置动态路由\u0026#34;); permissions.value.forEach(route =\u0026gt; { if (!router.hasRoute(route.name)) { router.addRoute(route); log(\u0026#39;动态添加路由: %s\u0026#39;, route.name); } }); userStore.setHasInitDynamicRoute(); return { ...to, replace: true }; } log(\u0026#34;已登录 + 权限缓存有值 + 已设置动态路由\u0026#34;); return true; } }); } 这样设置后，当你刷新页面时，Pinia Store 会从 localStorage 恢复状态，保持用户登录信息和权限数据。\n","date":"2024-07-25T10:34:17+08:00","permalink":"http://localhost:1313/p/store-for-pinia%E4%BD%BF%E7%94%A8/","title":"Store For Pinia使用"},{"content":"在设计后端接口的状态码和响应码体系时，我们需要考虑 HTTP 状态码与业务逻辑状态码的结合。HTTP 状态码用于描述 HTTP 请求的状态，而业务逻辑状态码（通常称为 code）用于描述应用程序特定的状态或错误。以下是一个推荐的设计方案：\nHTTP 状态码\r2xx 成功\n200 OK - 请求成功 201 Created - 创建成功 204 No Content - 无内容（通常用于 DELETE 请求） 4xx 客户端错误\n400 Bad Request - 客户端请求无效 401 Unauthorized - 未认证 403 Forbidden - 无权限 404 Not Found - 资源未找到 409 Conflict - 资源冲突 5xx 服务器错误\n500 Internal Server Error - 服务器内部错误 502 Bad Gateway - 网关错误 503 Service Unavailable - 服务不可用 业务逻辑状态码\r成功状态码\rCode Message Description 0 Success 请求成功 客户端错误码\rCode Message Description 1000 Invalid Parameters 参数无效 1001 Authentication Failed 认证失败 1002 Access Denied 权限不足 1003 Resource Not Found 资源未找到 1004 Resource Conflict 资源冲突 服务器错误码\rCode Message Description 2000 Internal Error 服务器内部错误 2001 Service Unavailable 服务不可用 2002 Gateway Error 网关错误 示例响应格式\r1 2 3 4 5 6 7 { \u0026#34;code\u0026#34;: 0, \u0026#34;message\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;exampleField\u0026#34;: \u0026#34;exampleValue\u0026#34; } } 示例错误响应\r客户端错误\r1 2 3 4 5 { \u0026#34;code\u0026#34;: 1001, \u0026#34;message\u0026#34;: \u0026#34;Authentication Failed\u0026#34;, \u0026#34;data\u0026#34;: null } 服务器错误\r1 2 3 4 5 { \u0026#34;code\u0026#34;: 2000, \u0026#34;message\u0026#34;: \u0026#34;Internal Error\u0026#34;, \u0026#34;data\u0026#34;: null } 状态码与业务逻辑码映射\r在实际开发中，可以将 HTTP 状态码和业务逻辑码结合起来使用，以便前端开发人员和 API 用户能够明确地知道发生了什么问题。例如：\n请求成功\nHTTP 状态码：200 业务逻辑码：0 响应体： 1 2 3 4 5 6 7 { \u0026#34;code\u0026#34;: 0, \u0026#34;message\u0026#34;: \u0026#34;Success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;exampleField\u0026#34;: \u0026#34;exampleValue\u0026#34; } } 参数无效\nHTTP 状态码：400 业务逻辑码：1000 响应体： 1 2 3 4 5 { \u0026#34;code\u0026#34;: 1000, \u0026#34;message\u0026#34;: \u0026#34;Invalid Parameters\u0026#34;, \u0026#34;data\u0026#34;: null } 服务器内部错误\nHTTP 状态码：500 业务逻辑码：2000 响应体： 1 2 3 4 5 { \u0026#34;code\u0026#34;: 2000, \u0026#34;message\u0026#34;: \u0026#34;Internal Error\u0026#34;, \u0026#34;data\u0026#34;: null } 这种设计使得 API 使用者能够从 HTTP 状态码了解请求的基本状态，并从业务逻辑码了解更详细的错误信息或业务状态。\n","date":"2024-07-24T16:45:59+08:00","permalink":"http://localhost:1313/p/fanpin%E6%8E%A5%E5%8F%A3%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E5%93%8D%E5%BA%94%E7%A0%81%E4%BD%93%E7%B3%BB/","title":"FanPin接口业务逻辑状态码和响应码体系"},{"content":"配置Axios响应拦截器\r为了配置 Axios 直接返回 response.data，可以使用 Axios 的响应拦截器。这样，每次请求时，你的代码只会处理响应数据，而不是整个响应对象。\n下面是如何配置 Axios 拦截器来实现这一点的步骤：\n创建 Axios 实例并配置拦截器： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import axios, { AxiosResponse } from \u0026#39;axios\u0026#39;; // 创建 Axios 实例 const axiosInstance = axios.create( // 实例默认值 { baseURL: \u0026#39;http://your-api-base-url\u0026#39;, timeout: 10000, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, } ); // 配置响应拦截器 axiosInstance.interceptors.response.use( (response: AxiosResponse) =\u0026gt; response.data, (error) =\u0026gt; { // 处理错误 return Promise.reject(error); } ); // 导出 Axios 实例 export default axiosInstance; 使用配置好的 Axios 实例进行请求： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import axiosInstance from \u0026#39;./path-to-your-axios-instance\u0026#39;; interface UserProfileDTO { roles: string[]; permissions: string[]; } interface UserProfileRequestParams { userId: string; } export const getUserProfile = (params: UserProfileRequestParams): Promise\u0026lt;UserProfileDTO\u0026gt; =\u0026gt; { return axiosInstance.get\u0026lt;UserProfileDTO\u0026gt;(\u0026#34;/system/v1/user/profile\u0026#34;, { params }); }; // 调用请求函数 const fetchUserProfile = async () =\u0026gt; { try { const data = await getUserProfile({ userId: \u0026#39;12345\u0026#39; }); console.log(\u0026#34;User Profile:\u0026#34;, data); const { roles, permissions } = data; console.log(\u0026#34;Roles:\u0026#34;, roles); console.log(\u0026#34;Permissions:\u0026#34;, permissions); } catch (error) { console.error(\u0026#34;Error fetching user profile:\u0026#34;, error); } }; // 执行函数 fetchUserProfile(); 解释\r创建 Axios 实例：\n使用 axios.create 方法创建一个 Axios 实例，并配置基础 URL、超时和默认头部。 配置响应拦截器：\n使用 axiosInstance.interceptors.response.use 方法添加一个响应拦截器。 在拦截器中，将 response.data 返回，从而使所有通过该实例进行的请求都只返回数据部分。 导出配置好的 Axios 实例：\n将配置好的 Axios 实例导出，以便在其他地方使用。 使用 Axios 实例进行请求：\n在请求函数 getUserProfile 中，使用配置好的 Axios 实例进行请求。 因为拦截器已经处理了响应对象，所以 getUserProfile 直接返回 response.data。 调用和处理请求：\n在 fetchUserProfile 函数中调用 getUserProfile，并直接获取数据部分。 处理并使用响应数据。 指定入参 \u0026amp; 响应数据类型\r在使用 Axios 进行 HTTP 请求时，可以通过泛型来指定请求参数和响应数据的类型。\n","date":"2024-07-24T14:06:40+08:00","permalink":"http://localhost:1313/p/axios%E4%BD%BF%E7%94%A8/","title":"Axios使用"},{"content":"Promise 基础\r代码示例：创建一个基本的Promise\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 let promise = new Promise(function(resolve, reject) { // 异步操作代码 setTimeout(() =\u0026gt; { resolve(\u0026#34;操作成功\u0026#34;); }, 1000); }); // resolve()执行后， then方法里面的内容才会执行 await promise.then( // 第一个参数为resolve()方法的回调 (value) =\u0026gt; { console.log(value); // 输出：操作成功 }); console.log(\u0026#39;代码结束！\u0026#39;) Promise 的状态\r一个Promise有三种可能的状态：\npending（待定） ：初始状态，既不是成功，也不是失败。 fulfilled（已实现） ：意味着操作成功完成。 rejected（已拒绝） ：意味着操作失败。\n","date":"2024-07-24T13:43:09+08:00","permalink":"http://localhost:1313/p/promise%E4%BD%BF%E7%94%A8/","title":"Promise使用"},{"content":"配置\r软件名 版本 备注 Docker latest ","date":"2024-07-23T14:06:47+08:00","permalink":"http://localhost:1313/p/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%80%BB%E8%A7%88/","title":"项目配置总览"},{"content":"总体\r落第一笔前，就得清楚第二笔的方向 放松但不随意的坐姿 线条长的笔画，笔尖不能压得太快，不然后面没空间操作 放松双指 拆分笔画，把每一笔的功夫做到位，其中落笔点是所有笔画的起始笔画 点\r风格一 第一阶段短\r轻点 缓慢加重，运笔很短一小段 风格二 第一阶段长\r轻点 缓慢加重 Q \u0026amp; A\r运笔方向和手臂方向很重要 总结\r第一阶段较为横向移动。才能对比最后停顿往下收笔那一段 30天速成日记\r日期 内容 总结 备注 2024/7/23 落笔点、点、竖点（小） 2024/7/24 落笔点、点 运笔整个过程要行云流水~ 两种风格：1. 起笔线条短 2. 起笔线条偏长，逐渐加粗（第一阶段）\n今天状态还可以，没那么着急。并且能很好地调节自己，放松手掌手指、写一个字调节肘部支点位置 2024/7/25 落笔点、点 1. 落笔到运笔的流畅性\n2. 放松双指\n3. 缓慢加重的过程 2024/7/26 落笔点、点 1. 用笔轻重：加重的节奏看笔画的长度\n2. 落笔点要流畅的衔接好第一笔，所以得提前清楚第二笔的方向 2024/7/27 2024/7/28 2024/7/25 ","date":"2024-07-23T09:10:52+08:00","permalink":"http://localhost:1313/p/%E7%A1%AC%E7%AC%94%E4%B9%A6%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","title":"硬笔书法学习总结"},{"content":"嵌套路由\rVue Router 提供了多层次的路由视图功能。每个 标签都表示一个嵌套路由视图。这使得在同一个应用中可以实现复杂的嵌套布局和路由逻辑。\n在项目中包含多个 \u0026lt;router-view\u0026gt; 标签，这是因为 Vue Router 允许嵌套路由。详细解释：\n嵌套路由允许在父组件中嵌套子组件的路由，这样可以组织和管理复杂的路由结构。例如，你可能有一个主布局组件，它包含一个导航栏和一个主内容区域，主内容区域会根据当前的路由展示不同的组件。\n在项目中，App.vue 包含一个 \u0026lt;router-view\u0026gt;，这表示主布局区域会根据当前路由展示不同的组件，如登录界面、登录成功后的导航栏和一个主内容区域。而在主内容区域 appMain.vue 中，又嵌套了一个 \u0026lt;router-view\u0026gt;，这表示在这个主内容区域中还可以进一步根据路由展示子组件。\n嵌套路由配置\r路由配置可以包含嵌套路由。例如，在主布局中可以有一个 ，在某些子组件中也可以有 ，用于渲染进一步嵌套的路由组件。\n在项目中有以下路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // src/router/index.ts const publicRoutes: RouteRecordRaw[] = [ { path: \u0026#34;/login\u0026#34;, name: \u0026#34;Login\u0026#34;, component: () =\u0026gt; import(\u0026#34;@/views/login/index.vue\u0026#34;), }, { path: \u0026#34;/\u0026#34;, name: \u0026#34;home\u0026#34;, component: Layout, redirect: \u0026#34;/home\u0026#34;, children: [ { path: \u0026#34;/home\u0026#34;, // 首页 component: () =\u0026gt; import(\u0026#34;@/views/home/index.vue\u0026#34;), }, { path: \u0026#34;/user\u0026#34;, // 用户管理 component: () =\u0026gt; import(\u0026#34;@/views/system/user/index.vue\u0026#34;), }, ], }, ... ]; 在这个配置中，Layout 组件包含一个 \u0026lt;router-view\u0026gt; 用于展示 Home 和 User 组件。\n代码解释\r在项目中，src/App.vue 是应用的根组件, 包含一个\u0026lt;router-view\u0026gt; 用于渲染主要内容：\n1 2 3 4 5 \u0026lt;template\u0026gt; \u0026lt;el-config-provider\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/el-config-provider\u0026gt; \u0026lt;/template\u0026gt; 而在 src/layout/main/index.vue 中，有一个嵌套的 \u0026lt;router-view\u0026gt;，这意味着在这个主内容区域内还可以根据子路由展示不同的组件：\n1 2 3 \u0026lt;template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/template\u0026gt; 这个结构允许在主内容区域中进一步嵌套子内容，从而实现更复杂的布局和路由结构。\n总结\r通过使用多个 \u0026lt;router-view\u0026gt;，可以创建复杂的路由结构，嵌套路由和命名视图都可以帮助更好地组织和管理 Vue 3 应用。这个功能使得 Vue Router 非常灵活，能够处理各种复杂的导航需求。\n命名视图\r允许在同一页面中渲染多个视图。 命名视图允许在同一个路由下显示多个组件。你可以给 \u0026lt;router-view\u0026gt; 标签添加一个 name 属性来指定视图的名称，这样可以在路由配置中定义多个视图。\n","date":"2024-07-22T16:21:05+08:00","permalink":"http://localhost:1313/p/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E5%92%8C%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"嵌套路由和命名视图的使用"},{"content":"配置项解释\r这个配置使用了 vite-plugin-mock 插件来简化 Mock.js 的集成，具体配置项如下：\n1 2 3 4 5 6 7 8 9 10 viteMockServe({ mockPath: \u0026#34;mock\u0026#34;, localEnabled: true, prodEnabled: false, injectCode: ` import { setupProdMockServer } from \u0026#39;./mock/mockProdServer\u0026#39;; setupProdMockServer(); `, logger: false }) mockPath:\nmockPath: \u0026quot;mock\u0026quot;：指定存放 Mock 数据的目录。这里指定为 \u0026quot;mock\u0026quot;，表示 Mock 数据文件放在项目根目录下的 mock 文件夹内。 localEnabled:\nlocalEnabled: true：在本地开发环境中启用 Mock 数据。true 表示总是启用 Mock 数据，不需要根据 command 来判断。 prodEnabled:\nprodEnabled: false：在生产环境中禁用 Mock 数据。false 表示即使在生产环境也不会启用 Mock 数据。 injectCode:\ninjectCode: ...：在打包后自动注入到入口文件中的代码。用于在生产环境中手动设置 Mock 数据。 具体代码为： 1 2 import { setupProdMockServer } from \u0026#39;./mock/mockProdServer\u0026#39;; setupProdMockServer(); 这段代码会在项目启动时执行 setupProdMockServer 方法，设置生产环境中的 Mock 数据。 logger:\nlogger: false：关闭日志输出。false 表示插件运行时不会输出日志信息，减少控制台输出内容。 使用示例\r以下是一个完整的 vite.config.ts 文件示例，展示了如何使用 vite-plugin-mock 插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import { defineConfig } from \u0026#39;vite\u0026#39;; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39;; export default defineConfig({ plugins: [ vue(), viteMockServe({ mockPath: \u0026#34;mock\u0026#34;, localEnabled: true, prodEnabled: false, injectCode: ` import { setupProdMockServer } from \u0026#39;./mock/mockProdServer\u0026#39;; setupProdMockServer(); `, logger: false }) ], server: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, // 你的后端服务地址 changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;) } } } }); mock 目录示例\r假设 mock 文件夹包含以下文件：\nsrc/mock/index.ts：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import { MockMethod } from \u0026#39;vite-plugin-mock\u0026#39;; export default [ { url: \u0026#39;/api/login\u0026#39;, method: \u0026#39;post\u0026#39;, response: () =\u0026gt; { return { code: 200, message: \u0026#39;登录成功\u0026#39;, data: { token: \u0026#39;1234567890abcdef\u0026#39; } }; } }, { url: \u0026#39;/api/user/info\u0026#39;, method: \u0026#39;get\u0026#39;, response: () =\u0026gt; { return { code: 200, message: \u0026#39;获取用户信息成功\u0026#39;, data: { id: 1, username: \u0026#39;admin\u0026#39;, role: \u0026#39;admin\u0026#39; } }; } } ] as MockMethod[]; src/mock/mockProdServer.ts：\n1 2 3 4 5 6 import { createProdMockServer } from \u0026#39;vite-plugin-mock/es/createProdMockServer\u0026#39;; import mockModules from \u0026#39;./index\u0026#39;; export function setupProdMockServer() { createProdMockServer(mockModules); } 解释\rmockPath 指定了 Mock 数据文件存放的目录。 localEnabled: true 表示始终在本地开发环境中启用 Mock 数据。 prodEnabled: false 表示在生产环境中不启用 Mock 数据。 injectCode 用于在项目启动时，自动注入设置 Mock 服务器的代码。 logger: false 表示关闭插件的日志输出，减少控制台输出内容。 通过这种配置方式，你可以在本地开发环境中使用 Mock 数据，而在生产环境中禁用 Mock 数据，确保开发和生产环境的行为一致。\n","date":"2024-07-21T20:02:14+08:00","permalink":"http://localhost:1313/p/mockjs/","title":"Mockjs"},{"content":"使用return {...}替代next({...})\r虽然 Vue Router 仍然支持 next 方法，但确实不再推荐使用它，并且官方文档中也建议避免使用。在 Vue 3 中，你可以通过返回一个 Promise 或直接返回一个路由路径来处理导航守卫逻辑，而不必使用 next 方法。\n以下是如何在全局导航守卫中实现 token 检查和重定向，而不使用 next 方法：\n配置 Vue Router\r在 src/router/index.js 中配置路由，并添加全局前置守卫：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39;; import Home from \u0026#39;@/views/Home.vue\u0026#39;; import Login from \u0026#39;@/views/Login.vue\u0026#39;; const routes = [ { path: \u0026#39;/\u0026#39;, component: Home, meta: { requiresAuth: true } }, { path: \u0026#39;/login\u0026#39;, component: Login }, ]; const router = createRouter({ history: createWebHistory(), routes, }); router.beforeEach((to) =\u0026gt; { const token = localStorage.getItem(\u0026#39;token\u0026#39;); if (to.meta.requiresAuth \u0026amp;\u0026amp; !token) { // 如果没有 token 且目标路由需要认证，则重定向到登录页 return { path: \u0026#39;/login\u0026#39; }; } // 否则继续导航 return true; }); export default router; 解释\rto：目标路由对象，表示即将要进入的目标。 from：当前导航正要离开的路由。 next 已被移除，替换为直接返回路由对象或 true。 改进的组件示例\r在 src/views 目录中创建 Home.vue 和 Login.vue 文件，定义组件内容：\nHome.vue:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Home\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to the home page.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;Home\u0026#39;, }; \u0026lt;/script\u0026gt; Login.vue:\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Login\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Please log in to continue.\u0026lt;/p\u0026gt; \u0026lt;!-- Login form and logic here --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;Login\u0026#39;, }; \u0026lt;/script\u0026gt; 在 Vue 应用中使用路由器和 Pinia\r在 src/main.js 中导入并使用路由器和 Pinia：\n1 2 3 4 5 6 7 8 9 import { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import router from \u0026#39;./router\u0026#39;; import { createPinia } from \u0026#39;pinia\u0026#39;; const app = createApp(App); app.use(router); app.use(createPinia()); app.mount(\u0026#39;#app\u0026#39;); 通过这种方式，你可以避免使用 next 方法，而是通过在导航守卫中返回路由路径或 true 来处理导航逻辑。这种方式更简洁，也避免了可能的错误来源。\n添加动态路由\r几个关键点\r后端返回的菜单要转化为标准的路由记录数据类型 后端返回的嵌套菜单数据结构是否能直接通过router.addRoute方法添加：可以，但是后端返回的component字段（前端组件路径）需要转换为实际的Vue组件 数据需要是标准的路由记录类型，才能被添加\n官方参考：添加路由\n标准的路由\rto.matched和to.meta方法\r在 Vue Router 中，route.meta 是一个有用的属性，它可以帮助你获取当前路由的合并的 meta 数据。这里的“非递归合并”指的是 Vue Router 在合并 meta 数据时并不会递归地处理所有父级路由的 meta 数据，而是直接将所有父级和子级路由的 meta 数据合并在一起。\nroute.meta 的功能和工作原理\r路由记录的合并：\n在 Vue Router 中，route.matched 数组包含了当前路由匹配到的所有路由记录。这些记录包括了当前路由以及它的所有父级路由。 你可以遍历这个数组来手动提取和合并 meta 数据。每个路由记录的 meta 数据可能会有不同的属性，这通常需要递归合并。 非递归合并：\nVue Router 提供了一个 route.meta 方法，它会将所有匹配的路由记录的 meta 数据合并为一个单一的对象。合并是“非递归”的，意味着它不会深入到子路由中进一步合并，而是直接将所有父级和子级的 meta 数据一并合成。 如果 meta 数据中存在相同的字段，后面定义的字段会覆盖前面的字段（类似于普通的对象合并）。 示例\r假设你有如下的路由配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const routes = [ { path: \u0026#39;/parent\u0026#39;, meta: { requiresAuth: true, role: \u0026#39;admin\u0026#39; }, children: [ { path: \u0026#39;child\u0026#39;, meta: { requiresAuth: true, permissions: [\u0026#39;read\u0026#39;] }, children: [ { path: \u0026#39;grandchild\u0026#39;, meta: { requiresAuth: false, permissions: [\u0026#39;write\u0026#39;] } } ] } ] } ]; 对于匹配到的 /parent/child/grandchild 路由，route.matched 数组将包含：\n/parent /parent/child /parent/child/grandchild 手动合并 meta 数据：\n1 2 3 4 5 const routeMeta = { ...route.matched[0].meta, ...route.matched[1].meta, ...route.matched[2].meta }; 使用 Vue Router 的 route.meta 方法：\n1 const routeMeta = route.meta; route.meta 合并后的结果：\n1 2 3 4 { requiresAuth: false, // 最终结果由最后一个子路由的 `meta` 决定 permissions: [\u0026#39;write\u0026#39;] // 最终结果由最后一个子路由的 `meta` 决定 } 总结\rroute.matched 数组包含了当前路由和所有父级路由的信息。 非递归合并 指的是 Vue Router 将所有这些 meta 数据直接合并为一个对象，而不是递归地处理每个子路由的 meta。 route.meta 方法会合并所有匹配的路由记录的 meta 数据，确保你可以方便地获取当前路由和所有父级路由的合并 meta 数据。 全局前置守卫\r怎么判断路由匹配成功？\rto.matched 属性来判断是否有路由匹配成功。to.matched 是一个数组，包含所有与目标路由匹配的路由记录。你可以检查这个数组是否为空来判断是否有路由匹配成功。\n设置动态路由\r在全局前置路由守卫中添加逻辑，动态地添加或修改路由。\n无论是否登录，对访问登录页的判断要放在前面\r例如当已登录，尚未初始化动态路由时，初始化动态路由完成后，重新导航会一直访问登录页\n已登录，但是未初始化动态路由时，访问登录页\r在动态路由初始化完成之前，用户不能访问登录页或其他受限页面。\n重新登录后，清空权限缓存\rhasInitDynamicRoute设为false 重置动态路由 ","date":"2024-07-19T17:00:23+08:00","permalink":"http://localhost:1313/p/vue-router-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/","title":"Vue Router 导航守卫"},{"content":"基本概念\r路由导航（Routing Navigation）是管理和切换应用程序页面的过程。\n路由基础\r路由记录 (Router Record)：我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。\n路由器 (Router): 路由器是一个 Vue 插件，它管理应用的所有路由，通过createRouter({...});创建一个路由器实例，并配置你的路由。\n路由 (Routes): 路由定义了 URL 路径与组件之间的映射关系。当用户访问特定 URL 时，路由器会渲染相应的组件。\n路由视图 (Router View): \u0026lt;router-view\u0026gt; 是一个占位符组件，路由器会在其中渲染匹配的组件。\n路由链接 (Router Link): \u0026lt;router-link\u0026gt; 是一个用于创建导航链接的组件，它会生成一个包含正确 href 属性的 \u0026lt;a\u0026gt; 标签。\n配置 Vue Router\r安装 Vue Router:\n1 npm install vue-router 创建路由配置: 在 src/router/index.js 中配置路由：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39;; import Home from \u0026#39;@/views/Home.vue\u0026#39;; import About from \u0026#39;@/views/About.vue\u0026#39;; const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About }, ]; const router = createRouter({ history: createWebHistory(), routes, }); export default router; 在 Vue 应用中使用路由器: 在 src/main.js 中导入并使用路由器：\n1 2 3 4 5 6 7 import { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import router from \u0026#39;./router\u0026#39;; const app = createApp(App); app.use(router); app.mount(\u0026#39;#app\u0026#39;); 使用路由组件\r创建组件: 在 src/views 目录中创建 Home.vue 和 About.vue 文件，定义组件内容。\n使用 \u0026lt;router-view\u0026gt; 渲染路由匹配的组件: 在 src/App.vue 中添加 \u0026lt;router-view\u0026gt;：\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;About\u0026lt;/router-link\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 导航守卫\rVue Router 提供了一些钩子函数，可以在导航发生前、导航中、导航后进行一些操作，比如权限验证、数据加载等。\n全局守卫:\n1 2 3 4 router.beforeEach((to, from, next) =\u0026gt; { // 逻辑操作 next(); }); 路由独享守卫:\n1 2 3 4 5 6 7 8 9 10 const routes = [ { path: \u0026#39;/about\u0026#39;, component: About, beforeEnter: (to, from, next) =\u0026gt; { // 逻辑操作 next(); } } ]; 组件内守卫:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 export default { beforeRouteEnter(to, from, next) { // 逻辑操作 next(); }, beforeRouteUpdate(to, from, next) { // 逻辑操作 next(); }, beforeRouteLeave(to, from, next) { // 逻辑操作 next(); } } 通过以上步骤，可以在 Vue 项目中实现基本的路由导航功能。\nVue Router API\r全局前置守卫\r全局前置守卫API\n入参 NavigationGuardWithThis\r官方文档不推荐使用next方法\r更多信息参考：Vue Router next方法平替\n公共路由定义\r定义用户都会有的公共页面的路由。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // src/router/index.ts const Layout = () =\u0026gt; import(\u0026#34;@/layout/index.vue\u0026#34;); const publicRoutes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: Layout, redirect: \u0026#39;/home\u0026#39;, children: [ { path: \u0026#39;/home\u0026#39;, // 捕获所有路由或 404 Not found 路由 component: () =\u0026gt; import(\u0026#39;@/views/home/index.vue\u0026#39;) } ] }, { path: \u0026#39;/404\u0026#39;, name: \u0026#39;404\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/error-page/404.vue\u0026#39;) }, { path: \u0026#39;/403\u0026#39;, name: \u0026#39;403\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/views/error-page/403.vue\u0026#39;) }, {path: \u0026#39;/login\u0026#39;, name: \u0026#39;login\u0026#39;, component: ()=\u0026gt; import(\u0026#39;@/views/login/index.vue\u0026#39;)}, ] 创建路由\r1 2 3 4 5 6 7 8 9 10 11 12 13 // src/router/index.ts /** * 创建路由 */ const router = createRouter({ history: createWebHashHistory(), routes: publicRoutes, // 刷新时，滚动条位置还原 scrollBehavior: () =\u0026gt; ({ left: 0, top: 0 }), }); export default router 全局注册路由实例\r1 2 import router from \u0026#39;@/router\u0026#39; app.use(router) 动态路由配置\r","date":"2024-07-16T11:25:52+08:00","permalink":"http://localhost:1313/p/vue3-bear-admin-%E8%B7%AF%E7%94%B1%E6%8C%87%E5%8D%97/","title":"Vue3-Bear-Admin 路由指南"},{"content":"总体布局\r侧边栏\r需求\r支持拖拽拉伸调整宽度 折叠/展开按钮 菜单项宽度铺满侧边栏； 菜单项较少时侧边栏高度也能充分展示 菜单项和 元素之间没有空白，我们可以设置 .sidebar-content 的高度自适应其内部菜单项的高度。 侧边栏拖拽实现\r1 pnpm add vue-resize-handle ","date":"2024-07-11T16:21:14+08:00","permalink":"http://localhost:1313/p/vue3-bear-admin%E5%B8%83%E5%B1%80%E6%8C%87%E5%8D%97/","title":"Vue3-Bear-Admin布局指南"},{"content":"CommonJS模块的导入和导出\r在 CommonJS 模块系统中，确实没有默认导出的概念。在 CommonJS 中，你可以使用 module.exports 或者 exports 来导出模块中的内容，但是没有像 ES6 中的默认导出那样的语法。例如，在 CommonJS 中，你可以这样导出一个模块：\n1 2 3 4 5 6 // moduleA.js const myFunction = () =\u0026gt; { // function implementation }; module.exports = myFunction; 然后在另一个文件中使用它：\n1 2 3 4 // main.js const myFunction = require(\u0026#39;./moduleA\u0026#39;); myFunction(); // 调用导入的函数 这里的 module.exports 将 myFunction 导出为模块的公共接口，可以被其他模块通过 require 导入和使用。\nCommonJS的module.exports和exports的区别\r在 Node.js 中，module.exports 和 exports 是相关但不完全相同的概念。\nmodule.exports:\n这是一个指向当前模块导出对象的引用。 默认情况下，module.exports 是一个空对象 {}。 如果你希望导出一个函数、对象或者其他内容作为模块的公共接口，你可以直接给 module.exports 赋值。 1 2 3 4 // 导出一个函数 module.exports = function() { console.log(\u0026#34;Hello\u0026#34;); }; exports:\nexports 是 module.exports 的一个引用。 在模块中，你可以向 exports 对象添加属性来导出多个值。 1 2 3 4 5 6 7 // 导出多个值 exports.sayHello = function() { console.log(\u0026#34;Hello\u0026#34;); }; exports.sayBye = function() { console.log(\u0026#34;Goodbye\u0026#34;); }; 在这个例子中，exports 是一个指向 module.exports 的引用，因此这两种方式都可以用来导出模块的内容。但是，如果你直接给 exports 赋一个新的值（引用值被覆盖了，如 exports = { ... }），那么它会断开与 module.exports 的关联，这会导致导出失败。\n总结来说，module.exports 是导出模块内容的主要方式，而 exports 是对 module.exports 的简便引用，用来导出多个值。\nNode.js 的 ES 模块和 CommonJS 兼容性\rNode.js 在处理 ES 模块和 CommonJS 模块之间的互操作性时，做了一些特殊处理：\nES 模块可以导入 CommonJS 模块:\n当你在 ES 模块中使用 import 语法导入 CommonJS 模块时，Node.js 会将 CommonJS 模块的导出对象作为默认导出。这意味着你可以直接使用 import moduleName from 'commonjs-module' 来导入一个 CommonJS 模块。 CommonJS 模块可以动态导入 ES 模块:\n当你在 CommonJS 模块中使用 import() 语法动态导入 ES 模块时，这种方式是支持的，因为动态导入 (import()) 是异步的，并且符合 ES 模块的加载机制。 示例\rCommonJS 模块 (commonjs-module.js)\r1 2 3 4 5 6 // commonjs-module.js module.exports = { bar: function() { console.log(\u0026#34;bar\u0026#34;); } }; ES 模块 (es-module.mjs)\r1 2 3 4 // es-module.mjs import commonjsModule from \u0026#39;./commonjs-module.js\u0026#39;; commonjsModule.bar(); // 输出 \u0026#34;bar\u0026#34; TypeScript 项目中的情况\r如果你在一个 TypeScript 项目中，没有配置 allowSyntheticDefaultImports 和 esModuleInterop，那么编译器会对导入语法有更多限制。然而，这些选项仅影响 TypeScript 编译器的行为，不影响 Node.js 的实际运行行为。\n示例\r即使没有配置 allowSyntheticDefaultImports 和 esModuleInterop，Node.js 仍然允许如下 ES 模块代码运行：\n1 2 3 4 // es-module.mjs import commonjsModule from \u0026#39;./commonjs-module.js\u0026#39;; commonjsModule.bar(); // 输出 \u0026#34;bar\u0026#34; allowSyntheticDefaultImports 和 esModuleInterop 的作用\r在 TypeScript 中配置这两个选项的作用如下：\nallowSyntheticDefaultImports:\n允许在没有默认导出的模块中使用默认导入。这对于兼容性非常有用，尤其是在导入 CommonJS 模块时。 esModuleInterop:\n启用对 ES 模块和 CommonJS 模块的互操作性支持，包括导入默认导出和命名导出。这在 TypeScript 编译过程中会生成额外的代码来处理这种兼容性。 总结\rNode.js 内置的 ES 模块和 CommonJS 模块兼容性处理: 即使没有在 tsconfig.json 中配置相关选项，Node.js 本身支持在 ES 模块中导入 CommonJS 模块。 TypeScript 配置的影响: allowSyntheticDefaultImports 和 esModuleInterop 主要影响 TypeScript 编译器行为，不影响 Node.js 的实际运行行为。如果你不配置这些选项，TypeScript 编译器可能会报告错误，但在 Node.js 中运行时仍然有效。 如果你有更多具体的项目配置或代码示例，我可以帮助你更深入地分析和解决问题。\nCommonJS和ESModule的兼容问题？\r没有默认导出的模块在兼容性方面可能会遇到一些问题，特别是在使用不同的模块系统（如 CommonJS 和 ES6 模块）时。以下是一些常见的兼容性问题和解决方法：\nCommonJS 模块\rCommonJS 模块使用 module.exports 和 require 语法，主要用于 Node.js 环境。\n1 2 3 4 5 6 // commonjsModule.js module.exports = { foo: function() { console.log(\u0026#34;foo\u0026#34;); } }; ES6 模块\rES6 模块使用 export 和 import 语法，主要用于现代浏览器和使用打包工具（如 Webpack、Rollup）的项目。\n1 2 3 4 // es6Module.js export const foo = () =\u0026gt; { console.log(\u0026#34;foo\u0026#34;); }; 兼容性问题\r默认导出和命名导出的区别\n如果一个模块使用 export default 导出，但被另一个模块使用 require 导入时，可能会遇到默认导出的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // es6Module.js export default { foo: function() { console.log(\u0026#34;foo\u0026#34;); } }; // 使用 CommonJS 导入报错 const es6Module = require(\u0026#39;./es6Module\u0026#39;); es6Module.foo(); // TypeError: es6Module.foo is not a function // 在 ES6 环境中，你可以这样导入： import es6Module from \u0026#39;./es6Module\u0026#39;; es6Module.foo(); 这是因为 require 导入的是整个模块对象，而不是默认导出。\nimport 没有默认导出的模块时报错\n如果一个模块没有默认导出，直接使用 import 默认导入会导致错误。\n1 2 3 4 5 6 7 8 9 10 // commonjsModule.js module.exports = { foo: function() { console.log(\u0026#34;foo\u0026#34;); } }; // 使用 ES6 导入 import commonjsModule from \u0026#39;./commonjsModule\u0026#39;; commonjsModule.foo(); // TypeError: commonjsModule.foo is not a function 解决方法\r使用命名导出\n如果模块没有默认导出，可以使用命名导出。\n1 2 3 4 5 6 7 8 9 10 // commonjsModule.js module.exports = { foo: function() { console.log(\u0026#34;foo\u0026#34;); } }; // 使用 ES6 导入 import { foo } from \u0026#39;./commonjsModule\u0026#39;; foo(); // 输出 \u0026#34;foo\u0026#34; 启用 TypeScript 编译选项\n如果你使用 TypeScript，可以启用 esModuleInterop 和 allowSyntheticDefaultImports 选项来处理兼容性问题。\n1 2 3 4 5 6 7 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true } } 混合使用 module.exports 和 export default\n可以同时使用 module.exports 和 export default 来确保模块在两种环境下都能正常工作。\n1 2 3 4 5 6 7 8 9 // commonModule.js const module = { foo: function() { console.log(\u0026#34;foo\u0026#34;); } }; module.exports = module; // CommonJS 导出 export default module; // ES6 导出 在 CommonJS 环境中：\n1 2 const commonModule = require(\u0026#39;./commonModule\u0026#39;); commonModule.foo(); // 输出 \u0026#34;foo\u0026#34; 在 ES6 环境中：\n1 2 import commonModule from \u0026#39;./commonModule\u0026#39;; commonModule.foo(); // 输出 \u0026#34;foo\u0026#34; 总结\r没有默认导出的模块在不同模块系统之间使用时可能会遇到兼容性问题。通过使用命名导出、启用 TypeScript 编译选项或混合使用 module.exports 和 export default 可以解决这些问题。根据你的项目需求和环境选择合适的方法来处理模块导出和导入。\n","date":"2024-07-09T10:41:47+08:00","permalink":"http://localhost:1313/p/es-module%E5%92%8Ccommonjs%E8%A7%A3%E6%9E%90/","title":"ES Module和CommonJS解析"},{"content":"allowSyntheticDefaultImports和esModuleInterop的区别\rallowSyntheticDefaultImports和esModuleInterop是TypeScript编译器（tsc）配置中的两个重要选项，它们各自具有不同的作用，但在某些情况下会协同工作以解决模块导入时的兼容性问题。以下是对这两个选项区别的详细解释：\nallowSyntheticDefaultImports\r作用：\nallowSyntheticDefaultImports允许开发者从不包含默认导出的模块中进行默认导入。这意味着，即使一个模块没有使用export default导出任何内容，开发者仍然可以使用import something from 'module'的语法来尝试导入它。 此选项仅影响类型检查，不会改变生成的JavaScript代码。如果模块实际上没有默认导出，运行时仍然会出错，除非模块或TypeScript的其他配置（如esModuleInterop）提供了相应的默认导出。 示例：\n假设有一个CommonJS模块，它没有默认导出，但有一个或多个命名导出。在默认情况下，TypeScript不允许使用默认导入语法来导入它。但是，将allowSyntheticDefaultImports设置为true后，TypeScript在类型检查时会忽略这个问题，允许开发者使用默认导入语法。\nesModuleInterop\r作用：\nesModuleInterop用于改进TypeScript与ES模块和其他模块系统（如CommonJS）之间的互操作性。当设置为true时，TypeScript会在编译过程中生成额外的代码，以确保模块能够正确地被导入和使用。 它主要通过提供两个帮助函数__importStar和__importDefault来实现这一点，这两个函数分别用于处理命名导入和默认导入的情况。 与allowSyntheticDefaultImports不同，esModuleInterop会改变生成的JavaScript代码，以确保导入的模块在运行时能够正常工作。 示例：\n当尝试从一个CommonJS模块中默认导入时，如果模块本身没有默认导出，esModuleInterop会生成额外的代码来模拟一个默认导出。这样，开发者就可以使用默认导入语法来导入模块，而不会在运行时遇到错误。\n区别总结\r影响范围：allowSyntheticDefaultImports仅影响类型检查，而esModuleInterop会改变生成的JavaScript代码。 目的：allowSyntheticDefaultImports的目的是允许开发者在不包含默认导出的模块上使用默认导入语法（尽管这可能导致运行时错误），而esModuleInterop的目的是改进模块之间的互操作性，确保导入的模块在运行时能够正常工作。 协同工作：在某些情况下，这两个选项会协同工作以解决模块导入时的兼容性问题。例如，当从CommonJS模块中默认导入时，可能需要同时设置allowSyntheticDefaultImports和esModuleInterop来确保类型检查和运行时行为都符合预期。 tsconfig.json中没有配置allowSyntheticDefaultImports和esModuleInterop为true，.mjs文件中也能使用import CommonJS模块\r在 Node.js 项目中，即使没有在 tsconfig.json 中配置 allowSyntheticDefaultImports 和 esModuleInterop 为 true，你仍然可以在 .mjs 文件中使用 import 来加载 CommonJS 模块。这是因为 .mjs 文件被默认识别为 ES 模块，并且 Node.js 有内置的兼容性处理。\ntsconfig.json中include的作用？\r在 tsconfig.json 文件中，include 配置项用于指定要包含在编译过程中的文件或目录。它接受一个字符串数组，每个字符串可以是一个文件路径或一个模式匹配表达式。\ninclude 的作用\rinclude 指定 TypeScript 编译器在编译时应包含的文件和目录。只有在 include 指定的文件和目录中的 TypeScript 文件才会被编译。include 配置项通常与 exclude 配置项配合使用，以排除不需要编译的文件或目录。\n示例\r基本示例\r1 2 3 { \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;] } 此配置指定 TypeScript 编译器应包含 src 目录下的所有 .ts 文件，以及其子目录中的所有 .ts 文件。\n配合 exclude 使用\r1 2 3 4 { \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;dist\u0026#34;, \u0026#34;**/*.js\u0026#34;, \u0026#34;node_modules\u0026#34;, \u0026#34;src/tests\u0026#34;] } 此配置指定 TypeScript 编译器应包含 src 目录下的所有 .ts 文件，以及其子目录中的所有 .ts 文件，但排除所有js文件和 dist、src/tests、node_modules 目录中的所有文件。\n注意事项\r如果未指定 include 和 files，TypeScript 编译器将默认包含项目根目录及其子目录中的所有 .ts、.tsx 和 .d.ts 文件（除 node_modules 和 outDir 指定的目录）。 include 和 files 都未指定时，TypeScript 将使用默认的包含模式。 总结\rinclude 配置项用于指定 TypeScript 编译器应包含在编译过程中的文件和目录。通过 include 可以明确告诉编译器哪些文件需要参与编译，这在大型项目中尤为重要，以确保编译过程高效且准确。\ntsconfig.json中compilerOptions.types的作用？\r在您提供的 tsconfig.json 配置片段中，\u0026ldquo;types\u0026rdquo;: [\u0026ldquo;node\u0026rdquo;] 指定了在 TypeScript 编译过程中仅包含 Node.js 的核心类型声明。这意味着，当您使用 Node.js 的 API 时，TypeScript 编译器将能够提供类型检查和自动补全功能。\n具体来说，\u0026ldquo;types\u0026rdquo;: [\u0026ldquo;node\u0026rdquo;] 的作用如下：\n包含 Node.js 类型声明：它告诉 TypeScript 编译器在编译过程中包含 Node.js 的类型声明文件。这些类型声明文件定义了 Node.js API 的形状，使得 TypeScript 能够理解并检查使用这些 API 的代码。 优化编译性能：通过仅包含必要的类型声明，可以减少 TypeScript 编译器需要处理的文件数量，从而提高编译性能。 避免类型冲突：如果您的项目中使用了多个库，并且这些库之间存在类型冲突，通过显式指定需要加载的类型声明文件，可以避免这些冲突。 在这个例子中，由于只指定了 \u0026ldquo;node\u0026rdquo;，所以 TypeScript 编译器将只会加载 Node.js 的类型声明，而不会加载其他库（如 React、Lodash 等）的类型声明，除非它们在代码中被显式引用或使用 /// 指令引入。\n如果您需要使用其他库的类型声明，可以在 \u0026ldquo;types\u0026rdquo; 数组中添加这些库的名称。例如，如果您还需要使用 React 的类型声明，可以将配置修改为：\n1 2 3 4 5 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;types\u0026#34;: [\u0026#34;node\u0026#34;, \u0026#34;react\u0026#34;] } } 这样，TypeScript 编译器在编译过程中就会同时包含 Node.js 和 React 的类型声明了。\ntsconfig.json中references的作用？\r在 TypeScript 项目中，references 配置项主要用于支持 TypeScript 项目引用（Project References） 功能。这一功能允许将一个大型项目分解成多个更小的、相互独立的子项目或包，从而提高代码管理的灵活性和编译速度。\n项目引用的好处\r增量编译：通过项目引用，TypeScript 只需要重新编译那些发生变化的子项目，而不是整个项目。 模块化：将项目拆分成多个模块，方便代码管理和维护。 独立构建：每个子项目可以独立构建和发布，适合构建大型单体应用或多个包的仓库（monorepo）。 如何使用项目引用\r配置项目引用：在根 tsconfig.json 中通过 references 指定要引用的子项目。 启用 composite：在所有被引用的子项目中，启用 composite 选项。 编译项目：通过 tsc --build 命令进行构建。此命令会自动处理项目间的依赖关系。 1 tsc --build 应用场景 - Vue3 + Vite\r以下是一个示例，展示了如何使用 references 配置项来管理项目引用。\n根 tsconfig.json\n根配置文件，指定项目引用：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;files\u0026#34;: [], \u0026#34;references\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;./tsconfig.app.json\u0026#34; }, { \u0026#34;path\u0026#34;: \u0026#34;./tsconfig.node.json\u0026#34; } ] } tsconfig.app.json\r前端项目的 TypeScript 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;composite\u0026#34;: true, // 被引用的项目必须启用新的 composite 设置。 \u0026#34;tsBuildInfoFile\u0026#34;: \u0026#34;./node_modules/.tmp/tsconfig.app.tsbuildinfo\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, \u0026#34;useDefineForClassFields\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;ES2020\u0026#34;, \u0026#34;DOM\u0026#34;, \u0026#34;DOM.Iterable\u0026#34;], \u0026#34;skipLibCheck\u0026#34;: true, /* Bundler mode */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;bundler\u0026#34;, \u0026#34;allowImportingTsExtensions\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true, \u0026#34;isolatedModules\u0026#34;: true, \u0026#34;moduleDetection\u0026#34;: \u0026#34;force\u0026#34;, \u0026#34;noEmit\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, /* Linting */ \u0026#34;strict\u0026#34;: true, \u0026#34;noUnusedLocals\u0026#34;: true, \u0026#34;noUnusedParameters\u0026#34;: true, \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;] } tsconfig.node.json\r为vite.config.js单独指定配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;composite\u0026#34;: true, // 被引用的项目必须启用新的 composite 设置。 \u0026#34;tsBuildInfoFile\u0026#34;: \u0026#34;./node_modules/.tmp/tsconfig.node.tsbuildinfo\u0026#34;, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;bundler\u0026#34;, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, \u0026#34;strict\u0026#34;: true, \u0026#34;noEmit\u0026#34;: true }, \u0026#34;include\u0026#34;: [\u0026#34;vite.config.ts\u0026#34;] } 应用场景 - Node.js项目\r在后端项目（使用 Node.js）中应用tsconfig.node.json\r在 Node.js 项目中，你可以使用 ts-node 或 tsc 命令来执行和编译代码。例如：\n使用 ts-node 运行 TypeScript 代码：\n1 ts-node -P tsconfig.node.json src/server.ts 使用 tsc 编译 TypeScript 代码：\n1 2 tsc -p tsconfig.node.json node dist/server.js 这样可以确保 Node.js 环境使用 tsconfig.node.json 中的配置进行 TypeScript 编译和执行。\n示例项目结构\r假设你的项目中既有前端代码，也有后端代码：\n1 2 3 4 5 6 7 8 9 10 11 project-root/ ├── src/ │ ├── client/ │ │ ├── components/ │ │ └── main.ts │ ├── server/ │ │ └── server.ts ├── tsconfig.json ├── tsconfig.app.json ├── tsconfig.node.json ├── vite.config.ts 在这种结构中：\n前端代码位于 src/client 目录下，使用 tsconfig.app.json 进行配置。 后端代码位于 src/server 目录下，使用 tsconfig.node.json 进行配置。 通过上述配置和使用方式，你可以确保在不同场景下正确地使用不同的 TypeScript 配置文件。\n总结\r项目引用是 TypeScript 提供的一项强大功能，允许将一个大型项目分解成多个更小的子项目，从而提高代码管理的灵活性和编译速度。通过在根 tsconfig.json 中配置 references，并确保所有子项目启用了 composite 选项，可以轻松实现项目引用。\n参考资料\r探究 tsconfig.node.json 文件和 references 字段的作用 ","date":"2024-07-09T10:28:13+08:00","permalink":"http://localhost:1313/p/tsconfig.json%E8%A7%A3%E6%9E%90/","title":"tsconfig.json解析"},{"content":"type\r在 Node.js 项目中，Node.js 会根据文件的扩展名和一些其他的规则来确定一个 JavaScript 文件是 CommonJS 模块还是 ES Module（ES6 模块）。\n判断规则：\r文件扩展名：\n如果文件的扩展名是 .js，Node.js 会将其视为 CommonJS 模块。 如果文件的扩展名是 .mjs，Node.js 会将其视为 ES Module（需要在文件中使用 import 和 export）。 package.json 中的 \u0026ldquo;type\u0026rdquo; 字段：\n如果在项目的 package.json 文件中设置了 \u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;，则 Node.js 会将项目中的所有 .js 文件都视为 ES Module。 如果没有设置 \u0026quot;type\u0026quot;: \u0026quot;module\u0026quot;，则 .js 文件默认为 CommonJS 模块。 导入语法：\n如果在一个 .js 文件中使用了 import 和 export 关键字来定义模块和导出变量或函数，则该文件会被视为 ES Module。 如果使用了 require() 和 module.exports 来导入和导出，则被视为 CommonJS 模块。 示例：\rCommonJS 模块\r1 2 3 4 5 6 7 8 // commonjsModule.js const message = \u0026#39;Hello from CommonJS Module!\u0026#39;; function greet() { console.log(message); } module.exports = { greet }; ES Module\r1 2 3 4 5 6 // esModule.js const message = \u0026#39;Hello from ES Module!\u0026#39;; export function greet() { console.log(message); } package.json 配置\r1 2 3 { \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34; } 在上述示例中，commonjsModule.js 使用 module.exports 导出，被视为 CommonJS 模块；而 esModule.js 使用 export 导出，被视为 ES Module。\n总结\rNode.js 根据文件的扩展名和导入导出的语法来判断一个 JavaScript 文件是 CommonJS 模块还是 ES Module。你可以通过设置 package.json 中的 \u0026quot;type\u0026quot; 字段来指定项目中的默认模块类型，或者根据需要选择使用 .js 或 .mjs 扩展名来明确文件的模块类型。\nES Module和CommonJS的兼容性问题\r在CommonJS中使用import语句：\n报错：Cannot use import statement outside a module\n在CommonJS中require(ES Module)： require()不支持直接导入ES模块，可以使用动态import()代替require()\n在ES Module中使用require(ES Module)语句：\nrequire()不支持直接导入ES模块，可以使用动态import()代替require() 支持require(CommonJS) 在ES Module中使用import CommonJS 正常\nhttps://www.cnblogs.com/ryelqy/p/11763473.html\n在CommonJS 模块中不支持require()直接导入 ES Module\r当你尝试在一个CommonJS环境中使用require()来导入一个ES模块时，会遇到ERR_REQUIRE_ESM错误，因为require()不支持直接导入ES模块。\n在JavaScript中，ES模块（ESM）和CommonJS模块有不同的导入和导出机制。当你尝试在一个CommonJS环境中使用require()来导入一个ES模块时，会遇到ERR_REQUIRE_ESM错误，因为require()不支持直接导入ES模块。\n解决方法\r使用动态import()代替require(): 动态import()可以在CommonJS模块中使用，它返回一个Promise对象，该对象解析为模块的引用。\n1 2 3 4 import(\u0026#39;./es6Module.mjs\u0026#39;).then((module) =\u0026gt; { module.default.foo(); module.esFoo(); }); 在ES Module中不支持require()直接导入 ES Module\r在 .mjs 文件中，也是可以使用 require 的，但是有一些需要注意的地方：\n默认限制：\n在 .mjs 文件中，你可以使用 require，但是有一个默认的限制，就是不能直接使用 require 导入另一个 .mjs 文件，这会导致 ERR_REQUIRE_ESM 错误。 解决方法：\n如果需要在 .mjs 文件中导入另一个 .mjs 文件，你可以通过以下两种方式解决：\na. 使用动态 import()：\n动态 import() 是 ES Module 的一部分，可以在所有的 CommonJS 模块和 ES Module 中使用。它是更加推荐和灵活的方式来导入模块。 1 2 3 4 5 6 7 import { createRequire } from \u0026#39;module\u0026#39;; const require = createRequire(import.meta.url); // 使用动态 import() 导入另一个 .mjs 文件 import(\u0026#39;./module.mjs\u0026#39;).then(module =\u0026gt; { // 在这里处理导入的模块 }); b. 修改文件扩展名：\n将你的 .mjs 文件改为 .js 文件，然后在该文件中使用 require 导入其他的 .mjs 文件。这样做可能会让 Node.js 将文件视为 CommonJS 模块，而不是 ES Module。 注意事项：\n如果你确实需要在 .mjs 文件中使用 require 导入其他 .mjs 文件，请确保理解 Node.js 对 ES Module 和 CommonJS 的处理方式，并根据具体情况选择合适的导入方式。 总结来说，.mjs 文件中可以使用 require，但需要注意不能直接使用 require 导入另一个 .mjs 文件，需要使用动态 import() 或者考虑修改文件扩展名等方法。\ntsconfig.json中的\u0026quot;module\u0026quot;: \u0026ldquo;ESNext\u0026quot;和package.json中的\u0026quot;type\u0026rdquo;: \u0026ldquo;module\u0026rdquo;,\r","date":"2024-07-08T13:39:30+08:00","permalink":"http://localhost:1313/p/package.json%E8%A7%A3%E6%9E%90/","title":"Package.json解析"},{"content":"项目初始化\rpnpm create vite vue3-bear-admin --template vue-ts 提交Git远程仓库 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/${你的用户名}/vue3-bear-admin.git git push -u origin main 目录介绍\rpackage.json\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { \u0026#34;name\u0026#34;: \u0026#34;vue3-bear-admin\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, // 声明整个项目是 ES 模块。 \u0026#34;type\u0026#34;: \u0026#34;module\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-tsc -b \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;vue\u0026#34;: \u0026#34;^3.4.29\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/node\u0026#34;: \u0026#34;^20.14.9\u0026#34;, \u0026#34;@vitejs/plugin-vue\u0026#34;: \u0026#34;^5.0.5\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^5.2.2\u0026#34;, \u0026#34;vite\u0026#34;: \u0026#34;^5.3.1\u0026#34;, \u0026#34;vue-tsc\u0026#34;: \u0026#34;^2.0.21\u0026#34; } } tsconfig.json\r根 tsconfig.json 用于设置基本的配置、路径别名和项目引用。\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;files\u0026#34;: [], \u0026#34;references\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;./tsconfig.app.json\u0026#34; }, { \u0026#34;path\u0026#34;: \u0026#34;./tsconfig.node.json\u0026#34; } ] } tsconfig.app.json 和 tsconfig.node.json 的使用取决于项目中不同的构建和运行场景。下面解释这两个配置文件在不同场景下的使用情况。\ntsconfig.app.json\r用于配置前端代码的 TypeScript 编译选项。例如：\n当你在 VSCode 或其他 IDE 中编辑前端 TypeScript 代码时，IDE 会根据 tsconfig.app.json 中的配置提供类型检查、代码补全和其他静态分析功能。 tsconfig.node.json\r用于配置 vite.config.ts 代码的 TypeScript 编译选项。\n项目配置\r路径别名\r配置 vite.config.ts\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; import { resolve } from \u0026#34;path\u0026#34;; import { defineConfig } from \u0026#39;vite\u0026#39;; /** 路径查找 */ const pathResolve = (dir: string): string =\u0026gt; { return resolve(__dirname, \u0026#34;.\u0026#34;, dir); }; /** 设置别名 */ const alias: Record\u0026lt;string, string\u0026gt; = { \u0026#34;@\u0026#34;: pathResolve(\u0026#34;src\u0026#34;), \u0026#34;@build\u0026#34;: pathResolve(\u0026#34;build\u0026#34;) }; // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue()], resolve: { alias }, }) 解决编辑器中的错误提示：无法找到模块“path”的声明文件\r原因\r出现这种警告的原因是 TypeScript 找不到 path 模块的类型声明文件。虽然 Node.js 本身提供了 path 模块，但在 TypeScript 项目中，我们需要额外安装类型声明文件来获得类型支持。\n解决方案\r可以通过以下步骤解决这个问题：\n安装 @types/node\npath 模块的类型声明文件包含在 @types/node 包中。您可以使用以下命令安装它：\n如果您使用 npm：\n1 npm install --save-dev @types/node 或者，如果您使用的是 pnpm：\n1 pnpm add -D @types/node 配置 tsconfig.app.json\r新增compilerOptions.paths、compilerOptions.types、exclude和baseUrl属性配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 { \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;], \u0026#34;exclude\u0026#34;: [ \u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34; ], \u0026#34;compilerOptions\u0026#34;: { \u0026#34;composite\u0026#34;: true, \u0026#34;types\u0026#34;: [\u0026#34;node\u0026#34;], // 优化编译性能。只会加载 Node.js 的类型声明，而不会加载其他库（如 React、Lodash 等）的类型声明 \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 解析非相对模块的基地址，默认是当前目录 \u0026#34;paths\u0026#34;: { // 用于定义模块路径的别名。 \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;], \u0026#34;@build/*\u0026#34;: [\u0026#34;build/*\u0026#34;] }, \u0026#34;tsBuildInfoFile\u0026#34;: \u0026#34;./node_modules/.tmp/tsconfig.app.tsbuildinfo\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;ES2020\u0026#34;, \u0026#34;useDefineForClassFields\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;ESNext\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;ES2020\u0026#34;, \u0026#34;DOM\u0026#34;, \u0026#34;DOM.Iterable\u0026#34;], \u0026#34;skipLibCheck\u0026#34;: true, /* Bundler mode */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;bundler\u0026#34;, \u0026#34;allowImportingTsExtensions\u0026#34;: true, \u0026#34;resolveJsonModule\u0026#34;: true, \u0026#34;isolatedModules\u0026#34;: true, \u0026#34;moduleDetection\u0026#34;: \u0026#34;force\u0026#34;, \u0026#34;noEmit\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, /* Linting */ \u0026#34;strict\u0026#34;: true, \u0026#34;noUnusedLocals\u0026#34;: true, \u0026#34;noUnusedParameters\u0026#34;: true, \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true }, } 验证\rNOTE: 一定重启您的开发环境（如 VSCode），以确保新的配置被正确加载。\n在App.vue组件中使用路径别名：\n1 2 3 4 // src/App.vue \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import HelloWorld from \u0026#39;@/components/HelloWorld.vue\u0026#39;; \u0026lt;/script\u0026gt; 兼容CommonJS 和 ES6 模块\r新增compilerOptions.allowSyntheticDefaultImports和compilerOptions.esModuleInterop属性\n启用 allowSyntheticDefaultImports 后，即使模块没有默认导出，你也可以使用默认导入语法。这在处理一些旧的或非标准的 JavaScript 模块时特别有用，因为这些模块可能没有使用 ES6 模块标准导出默认值。\n1 2 3 4 5 6 7 8 9 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { // 当设置为 true 时，allowSyntheticDefaultImports 允许默认导入非 ES6 模块（如 CommonJS 模块）。默认情况下，TypeScript 会将 import something from \u0026#39;module\u0026#39; 转换为 import something = require(\u0026#39;module\u0026#39;).default。如果模块没有默认导出，这会导致运行时错误。allowSyntheticDefaultImports 允许 TypeScript 假设每个模块都有一个默认导出，即使它不是用 ES6 语法编写的。 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // esModuleInterop 配置项与 allowSyntheticDefaultImports 紧密相关。当设置为 true 时，它允许 TypeScript 更好地遵循 ES6 模块互操作性规范，特别是关于默认导入的行为。具体来说，它会确保 CommonJS 和 ES6 模块之间的互操作性，允许从 CommonJS 模块中导入默认成员，即使它们没有显式地声明默认导出。 \u0026#34;esModuleInterop\u0026#34;: true, } } 按需导入\r安装依赖\n1 pnpm add -D unplugin-auto-import unplugin-vue-components 其中：\nunplugin-auto-import 自动导入API(在SFC内)。 例如vue的各种api。 1 2 import {ref, reactive} from \u0026#39;vue\u0026#39;// 配置自动导入，用来省略这句手动引入 const test = ref(\u0026#39;aaaa\u0026#39;) unplugin-vue-components 按需自动加载组件，插件会自动解析模板中的使用到的组件，并导入组件。 配置vite.config.ts\na. AutoImport 插件配置eslintrc 选项: 它的作用是自动生成 ESLint 配置文件，以确保自动导入的内容在代码质量检查中不会引起问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; // 按需注册全局导入 Register global imports on demand import AutoImport from \u0026#39;unplugin-auto-import/vite\u0026#39; // 按需导入组件 Components auto importing for Vue import Components from \u0026#39;unplugin-vue-components/vite\u0026#39; export default defineConfig({ // ... plugins: [ // ... AutoImport({ // 自动导入 Vue 相关函数，如：ref, reactive, toRef 等 imports: [\u0026#34;vue\u0026#34;], resolvers: [], // 生成自动导入的TS声明文件的路径 dts: \u0026#34;/auto-import.d.ts\u0026#34;, eslintrc: { // 是否启用自动生成 ESLint 规则文件。 // 1. 初次配置时设为 true 用于生成 ESLint 配置。启用时，插件会根据自动导入的内容生成一个 ESLint 配置文件，通常用于初次配置或需要更新规则时。 // 2. 在初次生成配置文件后改回 false。禁用时，避免重复生成 ESLint 配置文件，节省构建资源和时间。 enabled: true, // 指定生成的 ESLint 配置文件的路径。生成的文件将包含自动导入的函数和全局变量定义，确保 ESLint 能正确识别这些内容。 // 在您的主 ESLint 配置文件 .eslintrc 中，引用生成的 .eslintrc-auto-import.json 文件 filepath: \u0026#34;./.eslintrc-auto-import.json\u0026#34;, // 指定生成的 ESLint 配置文件中全局变量的属性值。 // true: 将全局变量标记为可读写（writable），意味着这些变量可以被重新赋值。 // false: 将全局变量标记为只读（readonly），意味着这些变量不能被重新赋值。 globalsPropValue: true, }, }), Components({ resolvers: [], // 生成自动导入组件的TS类型声明文件路径 dts: \u0026#34;types/components.d.ts\u0026#34;, }),], ], }) 配置tsconfig.json\n引入类型声明文件： json\r{\r\u0026quot;include\u0026quot;: [\r// ...\r\u0026quot;types/*.d.ts\u0026quot;\r],\r}\r引入打包分析插件 rollup-plugin-visualizer\r安装\r1 pnpm add -D rollup-plugin-visualizer 配置vite.config.ts\r1 2 3 4 5 6 7 8 9 10 11 12 import { visualizer } from \u0026#39;rollup-plugin-visualizer\u0026#39;; export default defineConfig({ // ... plugins: [ // ... visualizer({ open: true, // 构建后自动打开报告 brotliSize: true, // 显示 Brotli 压缩后的文件大小 filename: \u0026#39;build_report.html\u0026#39; // 报告文件的名称 }) ] }) visualizer 插件的这三个配置项用于控制生成的可视化报告的行为和内容。以下是每个配置项的详细解释：\nopen: true：\n作用：构建完成后，自动打开生成的可视化报告文件。 解释：如果设置为 true，当构建完成后，会自动在默认浏览器中打开生成的报告文件，方便开发者立即查看。 brotliSize: true：\n作用：在生成的报告中显示 Brotli 压缩后的文件大小。 解释：Brotli 是一种高效的压缩算法，比 gzip 更加高效。如果设置为 true，在报告中会额外显示每个文件经过 Brotli 压缩后的大小，帮助开发者了解应用在不同压缩算法下的大小表现。 filename: 'report.html'：\n作用：指定生成的可视化报告文件的名称。 解释：设置生成的 HTML 报告文件的名称和路径。默认情况下，报告文件会生成在项目的根目录下。你可以通过设置这个选项来更改文件的名称和保存路径。 通过这些配置，你可以在每次构建后自动生成并打开一个包含详细文件大小信息（包括 Brotli 压缩大小）的可视化报告文件 report.html。\n预览\r执行构建后，会自动打开浏览器显示可视化报告\n1 pnpm run build 整合ElementPlus\r安装\r安装依赖：\n1 pnpm install element-plus 配置ElementPlus组件按需导入\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; import AutoImport from \u0026#39;unplugin-auto-import/vite\u0026#39; import Components from \u0026#39;unplugin-vue-components/vite\u0026#39; import { ElementPlusResolver } from \u0026#39;unplugin-vue-components/resolvers\u0026#39; export default defineConfig({ // ... plugins: [ // ... AutoImport({ resolvers: [ // ... // 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式) ElementPlusResolver() // ... ] }), Components({ resolvers: [ // ... // 自动导入 Element Plus 组件 ElementPlusResolver() // ... ] }), ], }) 对比ElementPlus按需导入和完整引入的打包大小： 配置 Icon 自动导入\r安装\r1 pnpm add -D unplugin-icons 配置vite.config.ts\r保存以下配置后，会自动安装相关依赖，如@iconify-json/ep。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import { defineConfig } from \u0026#39;vite\u0026#39; import AutoImport from \u0026#39;unplugin-auto-import/vite\u0026#39; import Components from \u0026#39;unplugin-vue-components/vite\u0026#39; import Icons from \u0026#34;unplugin-icons/vite\u0026#34;; import IconsResolver from \u0026#34;unplugin-icons/resolver\u0026#34;; export default defineConfig({ // ... plugins: [ // ... AutoImport({ resolvers: [ // ... // 自动导入图标组件 IconsResolver({}), // ... ] }), Components({ resolvers: [ // ... // 自动注册图标组件 IconsResolver({ // 前缀 prefix: \u0026#34;i\u0026#34;, enabledCollections: [\u0026#34;ep\u0026#34;], }), // ... ] }), Icons({ // 自动安装图标库 autoInstall: true, }), ], }) 使用示例：\n命名规范\n根据 unplugin-icons 插件的文档，默认情况下，图标组件使用 i-{collection}-{icon} 这种命名规范，其中i为默认前缀，支持自定义.\n1 2 3 4 // 以 i 开头，即你配置的前缀 \u0026lt;IEpMenu /\u0026gt; \u0026lt;i-ep-Menu /\u0026gt; 参考资源\r使用 unplugin-icons 和 unplugin-auto-import 从 iconify 中自动导入任何图标集。 您可以参考此模板。\nElementPlus官网图标使用文档\n整合Pinia\r安装Pinia\r1 pnpm add pinia 配置\r新建src/store文件夹\n新建src/store/index.ts文件\n1 2 3 4 5 // src/store/index.ts import { createPinia } from \u0026#39;pinia\u0026#39; const pinia = createPinia() export default pinia 配置src/main.ts\n1 2 3 4 // ... import pinia from \u0026#39;./store\u0026#39; app.use(pinia) app.mount(\u0026#39;#app\u0026#39;) 配置自动导入\n1 2 3 4 5 6 7 8 9 10 11 12 13 export default defineConfig({ // ... plugins: [ // ... AutoImport({ imports: [ // ... \u0026#34;pinia\u0026#34; // ... ] }), ], }) 新建一个store\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // src/store/userStore.ts import { defineStore } from \u0026#39;pinia\u0026#39; // 你可以任意命名 `defineStore()` 的返回值，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。 // (比如 `useUserStore`，`useCartStore`，`useProductStore`) // 第一个参数是你的应用中 Store 的唯一 ID。 export const useUserStore = defineStore(\u0026#39;adminUser\u0026#39;, { state: () =\u0026gt; ({ count: 0 }), getters: { double: (state) =\u0026gt; state.count * 2, }, actions: { increment() { this.count++ }, }, }) 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // src/components/HelloWorld.vue \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { useUserStore } from \u0026#39;@/store/userStore\u0026#39;; defineProps\u0026lt;{ msg: string }\u0026gt;() const userStore = useUserStore() const { count } = storeToRefs(userStore) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; @click=\u0026#34;userStore.increment()\u0026#34;\u0026gt;useStore count is {{ count }}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 整合Vue-Router\r安装\r1 pnpm add vue-router@4 配置\r新建src/router 文件夹\n新建src/router/index.ts文件\n1 2 3 4 5 // src/router/index.ts import { createPinia } from \u0026#39;pinia\u0026#39; const pinia = createPinia() export default pinia 配置src/main.ts\n1 2 3 4 // ... import router from \u0026#39;@/router\u0026#39; app.use(router) app.mount(\u0026#39;#app\u0026#39;) 配置自动导入\n1 2 3 4 5 6 7 8 9 10 11 12 13 export default defineConfig({ // ... plugins: [ // ... AutoImport({ imports: [ // ... \u0026#34;vue-router\u0026#34; // ... ] }), ], }) 安装SCSS\r1 pnpm add -D sass 环境变量\r配置文件\r项目根目录新建 .env.development 、.env.production\n配置反向代理\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ... export default defineConfig({ // ... server: { proxy: { \u0026#34;/fp\u0026#34;: { // 这里填写本地环境后端地址 target: \u0026#34;http://127.0.0.1:18091\u0026#34;, changeOrigin: true, rewrite: path =\u0026gt; path.replace(/^\\/fp/, \u0026#34;\u0026#34;) } } }, // ... 配置Mockjs\r安装依赖\r1 2 3 pnpm add -D mockjs # 使用 vite-plugin-mock 插件来简化 Mock.js 的集成 pnpm add -D vite-plugin-mock 配置\r1 2 // vite.config.ts import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39;; ps： 更多关于Mockjs的信息参考：Mockjs指南\n整合Axios\r1 pnpm add axios 创建实例\r配置请求拦截器\r配置响应拦截器\r配置的优先级\r配置将会按优先级进行合并。它的顺序是：在lib/defaults.js中找到的库默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后面的优先级要高于前面的。\nQ \u0026amp; A\r接口请求载荷多了一堆无用的内容？\r问题详情\r原因\r使用了Vue的响应式对象作为请求数据。而Vue的响应式对象会携带一些内部属性，这些属性会在发送请求时一并发送出去。 ","date":"2024-07-04T16:34:21+08:00","permalink":"http://localhost:1313/p/vue3-bear-admin%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97/","title":"Vue3 Bear Admin项目指南"},{"content":"写在前面\r做好动作靠的不是一个个技术规范的条条框框，而是一个核心思想或核心动作。 比如高远球的核心就是展肩和确认步，侧身、并步仅仅是为了跑到击球位置，要想打好还得靠核心动作 又比如动态启动的核心思想是回动最后一步的节奏 意识\r放松\r放松，力量传导效率更高，也更省力。 架拍 转体 倒拍头 鞭甩击球，全过程保持放松，打出的动作才流畅、更有力。\n高点击球\r头顶正上方前10cm，一定不要太靠前\n瞬间发力\r急停（刹车）。动作不要太大，拍头在击球点停住。 借鉴网球发球。与网球发球时的倒拍、击球节奏有异曲同工之妙，好好想想，将感觉应用到羽毛球发力上！ 打在球的高点。身体发力会更自然、顺畅 哪一刻觉得自己提升了\r看到球头开始下坠的那一刻，我清醒的开始转体倒拍\r当你觉得球到了目标击球位置（高点），你才开始转体倒拍，打到球的时候，已经不是高点了。 启动\r动态启动\r放慢回动步的回来的最后一只脚，对手出球那一刻，球的位置决定脚放到哪： 1. 右前方，放到左脚的前面，做并步 2. 右后方，放到左脚后面，方便做交叉、并步\n静态启动\r节奏慢的时候用静态启动，也就是在对手即将击到球时的小跳\n高远球\r核心技术\r确认步\n降重心到后腿 把控距离，找到一个合适的击球位置 展肩\n两肩连起的直线朝向斜上方 稍稍往后收紧，避免含胸 左手高肘，大臂指向斜上方 击球时，左肩往后往下，右键往前往上高（顶）肘 肘部前移控制\n击球时应固定肘部，拍头位置才高；如果肘部前移，拍面会朝下 击球发力瞬间虎口握紧，其他时候放松、掌心留空隙握拍 Q \u0026amp; A\r展肩是在最后才做吗？架好拍后，就做好展肩吗？ 展肩和架拍并步移动的先后关系？\n步法\r往下压住弹力 启动时，双脚由合 -\u0026gt; 开，双脚展开距离要够大，太小移动的距离也太短了 球场点位\r正手四号位\r交叉步\r先动左脚，右脚着地时击球。\n回动：\n并步后压住膝盖，保持启动状态。回动步也是启动步。\nNOTE： 并步后的双脚距离要够大，这样才算正确的启动状态。\n并步\r跳换步击球\n回动：\n先动左脚，往前跨一步，然后双脚往前小跳启动，压住重心，保持弹性，储存弹力。\n正手二号位\r启动后，一个并步\nNOTE： 注意启动后双脚朝向接球点\n","date":"2024-07-04T09:59:49+08:00","permalink":"http://localhost:1313/p/%E7%BE%BD%E6%AF%9B%E7%90%832.5%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/","title":"羽毛球2.5进阶指南"},{"content":"写在前面\r不要被正手的掉拍头、拍头高度、收拍轨迹、匹配击球高度等条条框框限制住。\nNOTE： 后续所有动作都包含核心动作和核心思想，来指导所有技术细节\n心态第一\r不急于求成的心态会体现到击球节奏上\n意识第二\r主动发力动作短，被动发力长\r打在球弹起最高点\r身前处理球\r浅球跟上步伐，深球退后\n放弃发力，放松打球\r在十分放松和协调的情况下做动作，前期加速动作打出的球只会更不稳定 持拍手一定要放松 脚却要扎稳 这很矛盾 但却很重要 主动\r你打球，不是球打你。\n这就对你提出了要求：思路清晰、对球轨迹 \u0026amp; 落点明确、跑到位、准备好\n节奏感\r节奏：球朝你飞行过来的轨迹和你的挥拍轨迹的交点，必须是一个身前的击球点。\n球速快的时候，你的节奏也要快，这意味着要更早的挥拍 预判击球点的位置，提前挥拍，主动迎着球去打，节奏才能对上 动作连贯，对击球点充满信心，球虽未到，但自信朝着你想象的目标击球点挥拍！！！ 不能等到球弹到最高点，才开始挥拍。 盯球\r盯球辅助你更好的找到节奏感~\n对手拍碰到球，喊：“准备” 慢慢找到球到了你应该开始挥拍的位置，喊：“挥拍” 脚要提前到位等球\r靠着脚蹬转带动髋、身体打球，在这个基础上做到主动，意味着你脚开始蹬转要比球过来的节奏要快半拍\n脚步跑动要轻盈\r前脚掌踮起来启动，放松一点跑动\n越是快的球也是要放松身体\r浅的球要先超前跑动，然后侧身接最多两个并步\r用拍面轻轻推送，不一定要侧身做完整的动作\n正手\r核心动作\r1. 发力挥向击球点，打出‘啪’的感觉。就像羽毛球的高远球，我们短促发力鞭打在球的高点。\n在核心动作的指引下的其他动作细节变得简单：\n发力过程拍面的稳定性、拍面方向。 此时要做到向前推送，只需找到较前的击球点，让惯性自然产生推送效果 打上旋，力的方向角度较大朝上，拍头位置比击球点低 打平击，力的方向角度稍缓朝上，拍头略低于击球点 收拍轨迹也是自然产生的 2.\n哪一刻觉得自己提升了\r准备姿势\r左手握住球拍放在身前，盯球出那一刻，左手引拍\n屈膝\r降低重心后，会自然的把双脚打开：\n身体更稳了 步幅更大了 击球的高度也更合适了。\n以前教练说要在髋还是腰部高度击球，突然看了下自己的站姿，发现站太高了 另外好像\n保持大臂和腋下的间隙\r提升了拍头高度。 球拍往上的趋势变小了，把球没那么容易打飞 击球点变高了，没那么容易下网 更多的往前推送 击到球后，保持腋下打开状态，能更好的继续把拍头往前推送。而不会马上的向左收拍 打开/关闭腋下，带来的收拍效果不一样，下次可以好好观察。当你收腋时，往往伴随着屈肘吧？ 大臂会更好的向前 击到球后，保持腋下打开状态，能更好的继续将大臂往前送；如果关闭腋下，大臂没法划圆，也就没法往前走了 更好的收拍状态 打开腋下，收拍时肘部能收到肩膀位置，大小臂也处于更水平状态，肩膀能更多旋转\n关闭腋下，收完拍，小臂是朝上的，肩膀的旋转也不够\nNOTE: 说到收拍位置， 要想收拍到肩膀以上，并且最后大小臂保持水平，是不是也意味着转髋过程中，重心不能上移太多？\n大臂向前\r大臂往前，最终收拍姿势大臂和身体保持垂直\n反手挥拍直线轨迹\r拍头朝前直线挥拍\n发球\r抛球\n球未离开手时，不要抬头看球，这会导致身体变化，抛的球不稳定（球的上升轨迹是斜线）。球离开手后再盯球。 架拍\n往上抛球时，身体随之往上，持拍手逐渐架好拍（不要架太高），球脱手后，身体停住盯球，把握好节奏，然后放松倒拍顶肘 倒拍\n倒拍的节奏决定了你能否击到高点 击球\n击到球后，右脚尖不能脱离地面 挥拍、转髋和重心转移三者联系\r在网球挥拍过程中，挥拍、转髋和重心转移是互相联系、协调一致的三个重要动作。这三个动作的衔接和配合对于发力、稳定性和击球效果至关重要。以下是这三个动作如何衔接的详细描述：\n重心转移\r重心转移是整个挥拍过程中最先发生的动作。它帮助球员在击球时获得更大的力量和稳定性。\n准备阶段：在准备击球时，球员的重心通常是平衡的，双脚分开站立，稍微弯曲膝盖，准备随时移动。 启动重心转移：当球员决定击球时，重心会从后脚逐渐转移到前脚。对于右手球员，如果是正手击球，重心会从右脚转移到左脚；反手击球则相反。 重心转移的过程：重心的转移过程中，球员的身体会略微前倾，准备在击球时将全部力量集中在击球点上。 转髋\r转髋是通过髋部的旋转来产生额外的力量并将重心转移的力量传递到挥拍动作中。\n髋部预转：在准备击球时，球员的髋部会略微预转，以便在挥拍时能够顺利进行髋部的旋转。 髋部旋转：随着重心的转移，髋部开始旋转。对于右手球员，正手击球时，髋部从右向左旋转；反手击球则相反。 髋部的结束位置：髋部的旋转会带动上半身和手臂的挥拍动作，髋部旋转结束时，身体会面向球网。 挥拍\r挥拍是击球过程中最显著的动作，是将前面两个动作的力量集中到球上的关键步骤。\n准备挥拍：在重心开始转移和髋部预转的同时，球拍开始后引。 挥拍过程：随着髋部的旋转和重心的继续转移，球拍从后向前加速挥出，击中球的瞬间，所有的力量汇聚在球拍和球的接触点上。 随挥：击球后，球拍继续向前、向上挥动，这是随挥动作，可以帮助控制球的方向和力量，同时减少对身体的压力。 三者的协调\r同步启动：重心转移、转髋和挥拍通常是几乎同时开始的，但在时间上有微妙的先后顺序，重心转移稍微领先，然后是转髋，最后是挥拍。 力量传递：重心的转移提供了初始的力量和稳定性，转髋将这部分力量进一步放大并传递给上半身，最终通过挥拍将力量传递到球上。 流畅连接：为了最大化力量输出和保持动作的流畅性，重心转移、转髋和挥拍需要无缝连接，动作之间不能有明显的停顿或中断。 具体例子\r假设一个右手球员在进行正手击球：\n重心转移：球员站稳，重心在右脚。当准备击球时，重心从右脚逐渐转移到左脚。 转髋：同时，髋部从右向左旋转，带动上半身的转动。 挥拍：球拍后引，随着重心的转移和髋部的旋转，球拍快速向前挥动，击中球。击球后，球拍继续向前、向上随挥。 通过协调这三个动作，球员可以实现强而有力的击球，同时保持身体的平衡和稳定。练习时，可以分解动作，逐步练习重心转移、转髋和挥拍的协调性，最终将这些动作连贯起来。\n优良习惯\r盯球\r盯球不只盯球飞过来到快落地的时候，做到击打的时候，也盯着球\n手臂不发力\r手臂只是力量的传导，而非力量的来源。力量最终一定要传递至拍头，而不是拍柄。 和第二点相关，很多人把手臂当作一个力量来源来补充击球力量，这样会导致手臂僵硬。其实，在大部份正常情况下手臂几乎不太参与发力，更多只是控制方向的时候需要用到一点点力（处理一些救球或者随机球除外）。力量来源应该是：蹬地——转体——重心前压，然后力量是通过大臂——小臂——手腕，最终到达拍头（注意：我的用词是力量通过大臂小臂手腕，而不是大臂小臂手腕发力）。很多人手臂紧张，力量最终也就传递到了拍柄，拍头根本没出去。有一个比较好的心理上的技巧，我曾经尝试过：就是正反手把注意力都放在收拍那一下，因为你想着要快速收拍，你自然就放松了，力量就过度到拍头，球的包裹就完整了，然后鞭打就出来了。\n常见球处理 - 斜线球\r因为球的飞行是离你而去的，你要朝侧面跑的多一点\n注意事项\r","date":"2024-07-04T09:09:05+08:00","image":"http://localhost:1313/p/%E7%BD%91%E7%90%832.0%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/background_hu9591724bffec5aba40c9ea71c9b27ba2_214865_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/%E7%BD%91%E7%90%832.0%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/","title":"网球2.0进阶指南"},{"content":"生产环境服务器配置\rCPU 4核 内存 8GB\n带宽：5Mbps\n系统：Ubuntu 22.04 64位\n公网IP：117.77.72.171\n安装软件\r软件名 版本 备注 Docker latest 安装指引 生产环境准备\rDocker网络创建\r1 docker network create prod_fanpin_network ","date":"2024-07-02T15:22:39+08:00","image":"http://localhost:1313/p/fanpin%E7%94%9F%E4%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/%E6%9C%8D%E5%8A%A1%E5%99%A8_hudc00268aaa94cfe5e71e71a027d94c4a_42997_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/fanpin%E7%94%9F%E4%BA%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"FanPin生产服务器使用指南"},{"content":"生产环境上线指南\r生产环境部署\r登录。\ndocker login -u \u0026lt;USERNAME\u0026gt; -p \u0026lt;PASSWORD\u0026gt; g-jyhi6256-docker.pkg.coding.net\n删除历史容器\ndocker rm -f \u0026lt;PACKAGE\u0026gt;:\u0026lt;VERSION\u0026gt;\n启动新容器\ndocker run -d -it -p 80:80 --name fanpin-web-admin g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/\u0026lt;PACKAGE\u0026gt;:\u0026lt;VERSION\u0026gt;\n网络配置\n加入生产环境网络\n1 docker network connect prod_fanpin_network fanpin4cloud-system-biz 示例：\n1 2 3 4 5 6 7 8 9 10 11 # 登录 省略，请注意隐私保护 # 删除历史容器 docker rm -f fanpin4cloud-system-biz # 启动新容器 docker run -d -p 18091:18091 --name fanpin4cloud-system-biz g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/fanpin4cloud-system-biz:0.0.1-SNAPSHOT # 加入生产环境网络 docker network connect prod_fanpin_network fanpin4cloud-system-biz 预览\r访问首页:\n","date":"2024-07-02T15:11:24+08:00","image":"http://localhost:1313/p/fanpin%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E6%8C%87%E5%8D%97/background_hu3d103fc288eb5aacfe14c1eb11a8f32f_1202512_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/fanpin%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E6%8C%87%E5%8D%97/","title":"FanPin后台管理服务指南"},{"content":"s\r配置GitHub Pages\r在浏览器打开HTML 文件远程仓库的Setting页面https://github.com/${你的GitHub用户名}/${你的GitHub用户名}.github.io/settings\n扩展\r配置Stack主题\r举个例子\nQ \u0026amp; A\r克隆项目时，子模块没有被自动克隆？\r默认情况下子模块不会被自动克隆。你需要执行一些额外的命令来初始化并更新子模块。\n1 git submodule update --init --recursive 帖子内的目录展示不正常？\r不要写一级标题，从二级标题开始\n参考资料\rStack主题相关\r官方示例博客网站 官方文档 官方文档-中文 Stack主题HuGo项目快速开始 精品博客网站欣赏\rHugo Stack 第三夏尔 | Third Shire\n支持评论、聊天室 ","date":"2024-07-02T10:41:49+08:00","permalink":"http://localhost:1313/p/hugo-stack-guide/","title":"HuGo Stack主题使用指南"},{"content":"生产环境上线指南\r项目配置\r请求地址和Nginx反向代理后端服务匹配前缀\r请求地址 ip:port/${baseUrlApi}/${接口地址}，其中baseUrlApi配置在src/api/utils.ts的baseUrlApi常量。 Nginx反向代理后端服务匹配前缀 1 2 3 4 5 6 7 8 9 10 11 location /fp/ { proxy_pass http://127.0.0.1:18091/; proxy_set_header Host $host; proxy_set_header Cookie $http_cookie; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect default; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; } NOTE: baseUrlApi的值和Nginx配置的反向代理匹配的前缀要相同\n本地环境使用Docker调试\r启动容器\r项目根目录构建镜像: 1 docker build --no-cache --build-arg NGINX_CONF_PATH=local.nginx.conf -f local.df --tag local/fanpin-web-admin:0.0.1-SNAPSHOT . 本地环境容器启动命令: 1 docker run -d -it -p 80:80 --name local-fanpin-web-admin local/fanpin-web-admin:0.0.1-SNAPSHOT 访问http://localhost:80/admin 自查清单\r点击登录，查看请求访问网址（如http://localhost/fp/system/v1/auth/login/fp/system/v1/auth/login ）：\n前缀和src/api/utils.ts的baseUrlApi配置的前缀是否一致 本地镜像推送私有镜像仓库\r登录。\ndocker login -u \u0026lt;USERNAME\u0026gt; -p \u0026lt;PASSWORD\u0026gt; g-jyhi6256-docker.pkg.coding.net 打标签。\ndocker tag \u0026lt;LOCAL_IMAGE_TAG\u0026gt; g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/\u0026lt;PACKAGE\u0026gt;:\u0026lt;VERSION\u0026gt; 推送。\ndocker push g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/\u0026lt;PACKAGE\u0026gt;:\u0026lt;VERSION\u0026gt; 示例：\n1 2 3 4 5 6 7 8 # 登录 省略，请注意隐私保护 # 本地镜像打标签 docker tag local/fanpin-web-admin:0.0.1-SNAPSHOT g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/fanpin-web-admin:0.0.1 # 推送 docker push g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/fanpin-web-admin:0.0.1 生产环境部署\r登录。\ndocker login -u \u0026lt;USERNAME\u0026gt; -p \u0026lt;PASSWORD\u0026gt; g-jyhi6256-docker.pkg.coding.net\n删除历史容器\ndocker rm -f \u0026lt;PACKAGE\u0026gt;:\u0026lt;VERSION\u0026gt;\n启动新容器\ndocker run -d -it -p 80:80 --name fanpin-web-admin g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/\u0026lt;PACKAGE\u0026gt;:\u0026lt;VERSION\u0026gt;\n网络配置\n加入生产环境网络\n1 docker network connect prod_fanpin_network fanpin-web-admin 示例：\n1 2 3 4 5 6 7 8 # 登录 省略，请注意隐私保护 # 删除历史容器 docker rm -f fanpin-web-admin # 启动新容器 docker run -d -it -p 80:80 --name fanpin-web-admin g-jyhi6256-docker.pkg.coding.net/fanpin4cloud/fanpin4cloud/fanpin-web-admin:0.0.1 预览\r访问首页: http://${你的IP}/admin\n","date":"2024-07-01T16:51:15+08:00","image":"http://localhost:1313/p/fanpin-web%E6%8C%87%E5%8D%97/background_hu26dccd7c7cbf1ad33a50fd7a4df66012_29723_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/fanpin-web%E6%8C%87%E5%8D%97/","title":"FanPin Web指南"},{"content":"Markdown 语法\rMarkdown 链接示例\r1 2 3 4 5 6 7 8 9 10 11 这是一个 [Google](https://www.google.com) 的内联链接。 这是一个带有标题的 [Bing](https://www.bing.com \u0026#34;搜索引擎\u0026#34;) 的内联链接。 这是一个 [GitHub][1] 的参考链接。 这里是第二个 [GitHub][1] 的引用，指向相同的 URL。 \u0026lt;https://www.openai.com\u0026gt; 是一个自动链接。 [1]: https://www.github.com \u0026#34;GitHub 首页\u0026#34; 引用图片\r1 ![image](next_advice.png) ","date":"2024-07-01T15:42:29+08:00","image":"http://localhost:1313/p/markdown%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/background_hua48dd4fd16123727f053ad5b2e672363_11613_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/markdown%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97/","title":"Markdown写作指南"},{"content":"","date":"2024-07-01T15:20:38+08:00","image":"http://localhost:1313/p/%E6%9B%B2%E8%B0%B1/%E4%BA%94%E7%BA%BF%E8%B0%B1%E8%83%8C%E6%99%AF_huc809a33ee0a9870b97b8d319ee18fcad_460143_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/%E6%9B%B2%E8%B0%B1/","title":"曲谱"},{"content":"Windows 环境安装\r下载拓展版（Extended version）HuGo 压缩包\nNOTE: 标准版本没有 SCSS/SASS 支持\n解压缩后，配置 PATH 环境变量，方便使用 hugo 命令\n例如我的 PATH 环境变量的值是：D:\\Software\\hugo_extended_0.128.0_windows-amd64。\n验证安装。打开 CMD 窗口，执行以下命令\n1 2 D:\\Java\\Code\\hugo\u0026gt;hugo version hugo v0.128.0-e6d2712ee062321dc2fc49e963597dd5a6157660+extended windows/amd64 BuildDate=2024-06-25T16:15:48Z VendorInfo=gohugoio 如果您使用V的SCode 终端，配置好环境变量后，请重启VSCode\n项目初始化\r创建你的 HuGo 项目\n1 hugo new site username.github.io 目录介绍\narchetypes：存放内容类型的模板文件。当你使用 hugo new 命令创建新内容时，Hugo 会根据这里的模板文件生成相应的内容文件。你可以为不同的内容类型（如博客文章、页面等）定义不同的模板。 assets：这里存放用于 Hugo Pipes 的资源文件，例如 SCSS/SASS 样式表、JavaScript 文件等。Hugo Pipes 允许你对这些资源进行处理（如编译、压缩）并生成最终的静态文件。 content：主要存放网站的内容文件，如 Markdown 格式的博客文章、页面等。内容文件按照不同的分类和类型存放在子目录中。 data：存放数据文件，支持 YAML、JSON 和 TOML 格式。你可以在模板中通过 site.Data 访问这些数据文件，以便在网站生成时动态加载和使用数据。 i18n：国际化 layouts：存放定义网站的样式，写在layouts文件下的样式会覆盖安装的主题中的 layouts文件同名的样式。你可以在这里定义页面模板、部分模板（如头部、脚部）、列表模板等。模板文件使用 Go 模板语言编写。 public：存放 Hugo 生成的静态网页 static：存放静态文件（如图片、CSS、JavaScript 文件等），这些文件不会被 Hugo 处理，而是直接复制到最终生成的网站中。静态文件在网站中可以通过 /static/ 路径访问。 themes：存放主题文件夹。每个主题都有自己的目录，包含主题的模板、静态文件、资源文件等。你可以在 hugo.toml 或 hugo.yaml 中指定要使用的主题。 hugo.toml：网站配置文件。默认为toml格式，支持yaml格式 启动\n1 2 # -D 能看草稿文章 hugo server -D 预览\n本地访问网站的默认 URL：http://localhost:1313/\n撰写您的第一篇文章\r文章分类 \u0026amp; 标签\r当文章多了之后，content 目录会十分混乱，因此提前做好文章分类和标签很有必要~\n一级分类 一级分类目录路径 二级分类 二级分类目录路径 二级分类描述 三级分类目录路径 三级分类描述 #技术 post\\techs #HuGo hugo HuGo #Markdown markdown Markdown使用指南 #fanpin fanpin fanpin项目文档 deployment-guides 生产服务器环境安装及部署准备 system-biz fan4cloud-system-biz项目 web vue-pure-admin项目 #文学 post\\literature #中国 post\\literature\\china 国内文学 #法国 post\\literature\\franch 法国文学 #艺术 post\\arts #口琴 post\\arts\\harmonica 口琴曲谱、吹奏经验 #体育 post\\sports #网球 post\\sports\\tennis 网球技术归纳 #羽毛球 post\\sports\\badminton 羽毛球球技术归纳 分类 标签名 标签描述 开发语言 Go Java Python Vue3 项目文档 FanPin HuGo GitHub Pages DevOps Linux Ubuntu Markdown 布局文件创建\r在没有主题的情况下，需要手动创建一些基本的布局文件。步骤如下：\n在 layouts 目录中，创建一个名为 index.html 的文件： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt;{{ .Content }}\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 创建 layouts/_default/single.html 以渲染单个文章页面： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt;{{ .Content }}\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 文章创建\r1 hugo new post\\arts\\harmonica\\曲谱.md 预览文章\rhttp://localhost:1313/post/arts/harmonica/曲谱/\n更多文章撰写笔记相关文章：\n1. Markdown写作指南\n发布GitHub Pages·\r创建两个GitHub Repository\r第一个：HTML 文件远程仓库，存储HuGo项目构建后生成 HTML 文件。Repository name必须是你的用户名.github.io。比如我的命名为pierai.github.io 第二个：HuGo项目远程仓库 提交HuGo项目代码至HuGo项目远程仓库\r在提交前先配置.gitignore文件： 1 2 3 4 public resources assets/jsconfig.json .hugo_build.lock 初始化远程仓库： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 进入项目根目录 d: cd D:\\Java\\Code\\hugo # 初始化 Git 仓库 git init # 初始化 Git 仓库时创建的默认主分支名是 master。将 git init 创建的 master 修改成 main git init -b main # 如果这一步错过了修改分支名，推送前仍可修改本地分支名：git branch -m master main # 添加远程仓库 git remote add origin https://github.com/username/repository.git # 提交所有文件 git add . git commit -m \u0026#34;Initial commit\u0026#34; # 如果你的远程仓库中已经有一些提交，而本地仓库中没有这些提交（这通常发生在远程仓库中有初始的 README.md 文件或 .gitignore 文件。），需要执行以下命令： git pull origin main --allow-unrelated-histories # NOTE: 本地分支名要和远程分支对应 # 推送到远程仓库 git push -u origin main 构建并提交至HTML 文件远程仓库\r执行hugo server -D。不需要草稿文章则去掉-D参数。 NOTE: 草稿文章，也就是.md文件头部Frontmatter Configs中draft: false的文章。\n在项目根目录运行 hugo 命令将 Markdown 文件生成 HTML 文件到public文件夹。 1 2 3 4 # 进入项目根目录下的public文件夹 cd public # 重复上面的Git操作，将public下的所有文件提交到 HTML 文件仓库 预览\r浏览器访问: https://${你的GitHub用户名}.github.io/\n[可选]绑定个人域名\r获得GitHub域名解析出的IP\n1 nslookup ${你的GitHub用户名}.github.io 示例： 打开你的域名管理控制台，新增域名解析记录，其中：\n一条CNAME记录 第一步域名解析出几个IP就配置几条A记录 主机记录 记录类型 记录值 blog CNAME 你的GitHub Pages访问地址，比如我的是\u0026lt;pierai.github.io\u0026gt;. @ A 第一步解析出的IP 1 @ A 第一步解析出的IP 2 @ A 。。。 @ A 第一步解析出的IP N 示例： NOTE: 这里由于我的子域名负载均衡数量超出限制，A记录只配置了两条\nGitHub Settings配置\n打开GitHubHTML 文件远程仓库Settings配置 配置你的域名并Save 预览\n访问： https://你的域名/\n这里我访问自己博客的域名是:https://blog.somi.love/\n扩展\r配置stack主题\rHuGo Stack主题使用指南\nQ \u0026amp; A\r提交HTML 文件远程仓库代码冲突了？\r删除public文件夹， 重新hugo、hugo server -D、提交public文件夹到仓库\n更新 hugo.yaml 或 hugo.toml 文件配置后没生效？\r执行以下命令\n1 2 # 清除缓存 hugo --cleanDestinationDir 这个命令会执行以下操作：\n删除 public 目录中的所有文件和子目录。 根据你的内容和模板生成最新的静态文件。 将生成的静态文件输出到 public 目录。 详细说明\r清理目标目录：在构建网站之前，Hugo 会删除目标目录中的所有内容，确保没有旧的或不需要的文件。 构建网站：Hugo 会根据你的内容、模板、配置等生成最新的静态文件。 输出到目标目录：生成的静态文件会输出到目标目录（默认是 public）。 适用场景\r使用 --cleanDestinationDir 特别适用于以下场景：\n确保目录干净：确保发布目录中的文件都是最新的，没有遗留的旧文件，避免网站出现未更新或多余的文件。 自动化部署：在自动化部署脚本中使用，确保每次部署都从一个干净的目录开始，避免潜在的问题。 调试和开发：在开发过程中，确保每次构建都是干净的，方便调试和测试。 参考资料\rHuGo 完整安装包列表 如何用 GitHub Pages + Hugo 搭建个人博客 个人域名访问GitHub上部署的hugo博客 使用 Hugo 构建静态网站 使用 Hugo 和 GitHub Pages 搭建并部署一个静态博客网站 [] ","date":"2024-06-28T14:23:29+08:00","image":"http://localhost:1313/p/360%E6%97%A0%E6%AD%BB%E8%A7%92%E8%AE%B0%E5%BD%95hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%80/hugoblog_hu762191763670d76317483cc2e1c12c16_159252_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/360%E6%97%A0%E6%AD%BB%E8%A7%92%E8%AE%B0%E5%BD%95hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%80/","title":"360°无死角记录HuGo博客搭建（方式一）"}]